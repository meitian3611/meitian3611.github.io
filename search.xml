<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Sass</title>
    <url>/2019/10/31/Sass/</url>
    <content><![CDATA[<h2 id="Sass是什么"><a href="#Sass是什么" class="headerlink" title="Sass是什么"></a>Sass是什么</h2><blockquote>
<ul>
<li><p>SASS是一种动态的CSS（CSS预处理器），它扩展了 CSS 语法，</p>
</li>
<li><p>定义了一套新的语法规则和函数，以加强和提升CSS。</p>
</li>
<li><p>浏览器不认识sass，都需要编译成css文件！！</p>
</li>
<li><p>你仍然可以在Sass中写普通的CSS语句！</p>
</li>
</ul>
</blockquote><a id="more"></a>
<p>Sass 扩展了 css 的特性：</p>
<p>变量嵌套规则</p>
<p>@import导入样式</p>
<p>@mixin 混合器及传参</p>
<p>@extend 继承</p>
<p>@if、@for、@function 等</p>
<h3 id="软件方式编译"><a href="#软件方式编译" class="headerlink" title="软件方式编译"></a>软件方式编译</h3><p>使用Koala编译sass</p>
<p>koala是一个国产免费前端预处理器语言图形编译工具，支持Less、Sass、Compass、CoffeeScript，帮助web开发者更高效地使用它们进行开发。跨平台运行，完美兼容windows、linux、mac。</p>
<p>koala：<a href="http://koala-app.com/index-zh.html" target="_blank" rel="noopener">http://koala-app.com/index-zh.html</a></p>
<p><strong>注：以下均为scss语法</strong></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote>
<p>sass使用$符号来标识变量</p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$nav-color</span>: <span class="number">#F90</span>;</span><br><span class="line"><span class="variable">$width</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$nav-color</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译后</span></span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#F90</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><blockquote>
<p>在Sass中，你可以像俄罗斯套娃那样在规则块中嵌套规则块。</p>
<p>Sass允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器。</p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="selector-tag">h1</span>&#123;<span class="comment">//通过缩进用于嵌套</span></span><br><span class="line">        <span class="attribute">text-align</span>:center;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">span</span>&#123;</span><br><span class="line">        <span class="attribute">font-size</span>:<span class="number">16px</span>;</span><br><span class="line">        <span class="selector-tag">a</span>&#123;</span><br><span class="line">            <span class="attribute">color</span>:blue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//编译后</span><br><span class="line"><span class="number">#b</span>ox &#123;</span><br><span class="line">    width: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#box</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#box</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#box</span> <span class="selector-tag">span</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父选择器的标识符 <strong>&amp;</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>:red;</span><br><span class="line">    &amp;:hover&#123;</span><br><span class="line">        <span class="attribute">font-size</span>:<span class="number">60px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译后</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>:hover &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="import导入样式"><a href="#import导入样式" class="headerlink" title="@import导入样式"></a>@import导入样式</h3><blockquote>
<p>css有一个特别不常用的特性，即@import url()规则，它允许在一个css文件中导入其他css文件。 页面打开时，link引用的css文件被加载。而@import引用的CSS等页面加载完(DOM)之后再加载。</p>
</blockquote>
<blockquote>
<p>sass也有一个@import规则，但不同的是，sass的@import规则在生成css文件时就把相关文件导入进来。@import “b”;这条命令将把 b.scss文件中所有样式添加到当前样式表中</p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.scss</span></span><br><span class="line"><span class="variable">$width</span> : <span class="number">100px</span>;</span><br><span class="line"><span class="selector-class">.before</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">"b"</span>;</span><br><span class="line"><span class="selector-class">.after</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">$height</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.scss</span></span><br><span class="line"><span class="variable">$width</span> : <span class="number">200px</span>;</span><br><span class="line"><span class="variable">$height</span> : <span class="number">200px</span></span><br></pre></td></tr></table></figure>

<p><strong>编译后</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.css</span></span><br><span class="line"><span class="selector-class">.before</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.after</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="混合器-mixin"><a href="#混合器-mixin" class="headerlink" title="混合器 @mixin"></a>混合器 @mixin</h3><blockquote>
<p>你可以通过sass的混合器实现大段样式的重用。</p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> no-bullets &#123;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">    <span class="selector-tag">li</span> &#123;</span><br><span class="line">        <span class="attribute">list-style-image</span>: none;</span><br><span class="line">        <span class="attribute">list-style-type</span>: none;</span><br><span class="line">        <span class="attribute">margin-left</span>: <span class="number">0px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.plain</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">    @<span class="keyword">include</span> no-bullets;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后：</span></span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.plain</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.plain</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">list-style-image</span>: none;</span><br><span class="line">    <span class="attribute">list-style-type</span>: none;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>还可以给混合器传参</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> link-colors(<span class="variable">$normal</span>, <span class="variable">$hover</span>, <span class="variable">$visited</span>) &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$normal</span>;</span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="variable">$hover</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;:visited &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="variable">$visited</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    @<span class="keyword">include</span> link-colors(blue, red, green);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后：</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>:hover &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>:visited &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承-extend"><a href="#继承-extend" class="headerlink" title="继承@extend"></a>继承@extend</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fdd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">    @<span class="keyword">extend</span> .error; <span class="comment">//继承所有样式</span></span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后：</span></span><br><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fdd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fdd</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="颜色函数"><a href="#颜色函数" class="headerlink" title="颜色函数"></a>颜色函数</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$color</span>要改变的颜色，<span class="variable">$amount</span>取值范围是0~100%</span><br><span class="line">lighten(<span class="variable">$color</span>, <span class="variable">$amount</span>) <span class="comment">//颜色变浅函数；</span></span><br><span class="line">darken(<span class="variable">$color</span>, <span class="variable">$amount</span>) <span class="comment">//颜色变深函数；</span></span><br><span class="line"></span><br><span class="line">saturate(<span class="variable">$color</span>, <span class="variable">$amount</span>) <span class="comment">//增加颜色的饱和度；</span></span><br><span class="line">desaturate(<span class="variable">$color</span>, <span class="variable">$amount</span>) <span class="comment">//减少颜色的饱和度；</span></span><br><span class="line">grayscale(<span class="variable">$color</span>) <span class="comment">//将该颜色转换为相对应的灰度颜色；</span></span><br><span class="line">complement(<span class="variable">$color</span>) <span class="comment">//获取该颜色值旋转180度后相对应的颜色；</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>进阶提升</category>
      </categories>
      <tags>
        <tag>sass</tag>
        <tag>css扩展</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>gulp</title>
    <url>/2019/10/30/gulp/</url>
    <content><![CDATA[<h2 id="什么是Gulp"><a href="#什么是Gulp" class="headerlink" title="什么是Gulp"></a>什么是Gulp</h2><blockquote>
<p>Gulp是基于Node.js流的前端自动化构建工具</p>
<p>Gulp自动化构建工具可以增强你的工作流程！易于使用、易于学习、构建快速、插件高质！</p>
<p>在日常开发中，可以借助Gulp的一些插件完成很多的前端任务。</p>
<p>如：代码的编译（sass、less）、压缩css，js、图片、合并js，css、es6转es5、自动刷新页面等。</p>
</blockquote><a id="more"></a>
<h2 id="使用Gulp"><a href="#使用Gulp" class="headerlink" title="使用Gulp"></a>使用Gulp</h2><p>第一步先确保根目录存在 <code>package.json</code> 文件，执行 <code>npm init -y</code> 生成</p>
<p><strong>1. 全局安装gulp-cli脚手架</strong></p>
<p><code>npm install gulp-cli --global</code></p>
<p><strong>2. 安装项目开发依赖</strong></p>
<p><code>npm install gulp --save-dev</code></p>
<p><strong>3.在项目根目录下创建一个名为 gulpfile.js 的配置文件：</strong></p>
<p>此文件是项目主文件，运行gulp命令时，默认运行此文件</p>
<p><strong>4.命令行运行 gulp：</strong></p>
<p>gulp + 任务名</p>
<hr>
<h2 id="Gulp常用的API"><a href="#Gulp常用的API" class="headerlink" title="Gulp常用的API"></a>Gulp常用的API</h2><blockquote>
<p>task()、src()、dest()、watch()、series()、parallel()</p>
</blockquote>
<p><strong>gulp.task 方法用来注册任务</strong></p>
<blockquote>
<p>gulp.task(taskName, taskFunction)</p>
<p>taskName 为任务名</p>
<p>taskFunction 为任务函数，我们把任务要执行的代码都写在里面。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line">gulp.task(<span class="string">'task1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//注册任务task1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行task1'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>新版本<a href="mailto:Gulp@4.0" target="_blank" rel="noopener">Gulp@4.0</a>书写方式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTask</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行task2'</span>);</span><br><span class="line">    done(); <span class="comment">//异步任务完成</span></span><br><span class="line">&#125;</span><br><span class="line">exports.task2 = myTask; <span class="comment">//注册任务task2</span></span><br></pre></td></tr></table></figure>

<p><strong>gulp.dest 创建一个流，用于从文件系统读取元数据对象</strong>（用来读取文件）</p>
<blockquote>
<p>gulp.src(‘./js/a.js’); // 读取一个文件</p>
<p>gulp.src(‘./js/*.js’); // 读取js目录下的所有js文件</p>
<p>gulp.src([‘./js/a.js’,’./js/b.js’]); // 读取两个文件</p>
</blockquote>
<p><strong>gulp.dest 创建一个流，用于将元数据对象写入到文件系统</strong>（设置生成文件的路径）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line">gulp.task(<span class="string">'mytask'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">"./js/a.js"</span>)</span><br><span class="line">    .pipe(gulp.dest(<span class="string">"./dist"</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>读取文件流（gulp.src），通过管道（pipe），把文件流写入（gulp.dest）当前目录下的 dist 文件夹中</p>
<p><strong>gulp.watch  监听 globs 并在发生更改时运行任务</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'watchs'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//监听任务</span></span><br><span class="line">    <span class="comment">//当匹配任务变化时执行相应任务</span></span><br><span class="line">    gulp.watch(<span class="string">'./js/*.js'</span>,gulp.series(<span class="string">'concat'</span>));</span><br><span class="line">    gulp.watch(<span class="string">'./css/*.css'</span>,gulp.series(<span class="string">'task1'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>gulp.series() 将任务函数或组合操作组合成更大的操作（按顺序执行，同步）</strong></p>
<p><strong>gulp.parallel() 将任务函数或组合操作组合成更大的操作（同时进行，异步）</strong></p>
<hr>
<h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><p>常见问题解决方案：清理残留缓存<code>npm cache clean --force</code></p>
<p><strong>文件合并</strong></p>
<p>安装：<code>npm install --save-dev gulp-concat</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> concat = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>); <span class="comment">//引入插件</span></span><br><span class="line">gulp.task(<span class="string">'concat'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./js/*.js'</span>) 	<span class="comment">//要合并的文件</span></span><br><span class="line">    .pipe(concat(<span class="string">'main.js'</span>)) 		<span class="comment">//合并匹配到的js文件并命名为 "main.js"</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist/js'</span>));	<span class="comment">//写入dist/js文件夹下</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>js文件压缩</strong></p>
<p>安装：<code>npm install --save-dev gulp-uglify</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>); <span class="comment">//引入插件</span></span><br><span class="line">gulp.task(<span class="string">'uglifyJS'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./dist/main.js'</span>) <span class="comment">// 要压缩的js文件</span></span><br><span class="line">    .pipe(uglify()) 				<span class="comment">//使用uglify进行压缩</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist/js'</span>));	<span class="comment">//写入js文件夹</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>css文件压缩</strong></p>
<p>安装：<code>npm install --save-dev gulp-minify-css</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> minifyCss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);<span class="comment">//引入插件</span></span><br><span class="line">gulp.task(<span class="string">'minifyCss'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./dist/main.css'</span>) <span class="comment">// 要压缩的css文件</span></span><br><span class="line">    .pipe(minifyCss()) 				<span class="comment">//压缩css</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist/css'</span>));	<span class="comment">//写入dist文件夹</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>css/js文件合并压缩</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>); <span class="comment">//引入js压缩插件</span></span><br><span class="line"><span class="keyword">var</span> concat = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>); <span class="comment">//引入合并插件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//js文件的合并压缩</span></span><br><span class="line">gulp.task(<span class="string">'concatJs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src([<span class="string">'./js/*.js'</span>, <span class="string">'!./js/j*.js'</span>]) <span class="comment">//要合并的文件</span></span><br><span class="line">        .pipe(concat(<span class="string">'main.js'</span>)) 		<span class="comment">//合并匹配到的js文件并命名为 "main.js"</span></span><br><span class="line">        .pipe(uglify())					<span class="comment">//将合并后的js文件进行压缩</span></span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist/js'</span>))<span class="comment">//写入dist/js文件夹</span></span><br><span class="line">        .pipe(connect.reload())</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>html文件压缩</strong></p>
<p>安装：<code>npm install --save-dev gulp-minify-html</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> minifyHtml = <span class="built_in">require</span>(<span class="string">'gulp-minify-html'</span>);<span class="comment">//引入插件</span></span><br><span class="line">gulp.task(<span class="string">'minifyHtml'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./test.html'</span>) <span class="comment">//要压缩的html文件</span></span><br><span class="line">    .pipe(minifyHtml()) 			<span class="comment">//压缩html</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist/'</span>));	<span class="comment">//写入dist文件夹</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>重命名</strong></p>
<p>安装：<code>npm install --save-dev gulp-rename</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">var</span> rename = <span class="built_in">require</span>(<span class="string">'gulp-rename'</span>);<span class="comment">//引入插件</span></span><br><span class="line">gulp.task(<span class="string">'rename'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./js/jquery-1.8.3.js'</span>) <span class="comment">//读取文件</span></span><br><span class="line">    .pipe(uglify()) 						<span class="comment">//压缩</span></span><br><span class="line">    .pipe(rename(<span class="string">'jquery-1.8.3.min.js'</span>))	<span class="comment">//重命名</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist/js'</span>));			<span class="comment">//写入js文件夹</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><strong>ES6转ES5</strong></p>
<p>安装：<code>npm install --save-dev gulp-babel @babel/core @babel/preset-env</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</span><br><span class="line">gulp.task(<span class="string">'es6Toes5'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./js/class.js'</span>)</span><br><span class="line">    .pipe(babel(&#123; <span class="attr">presets</span>: [<span class="string">'@babel/preset-env'</span>]&#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist/js'</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>sass编译</strong></p>
<p>安装：<code>npm install --save-dev gulp-sass</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">"gulp-sass"</span>);</span><br><span class="line">gulp.task(<span class="string">'sass'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./test.scss'</span>)</span><br><span class="line">    .pipe(sass())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'compileSass'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.watch(<span class="string">'./test.scss'</span>,gulp.series(<span class="string">'sass'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><strong>*自动刷新</strong></p>
<p>安装：<code>npm install --save-dev gulp-connect</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);<span class="comment">//gulp包</span></span><br><span class="line"><span class="keyword">const</span> minifyHtml = <span class="built_in">require</span>(<span class="string">'gulp-minify-html'</span>);<span class="comment">//压缩html</span></span><br><span class="line"><span class="keyword">const</span> connect = <span class="built_in">require</span>(<span class="string">'gulp-connect'</span>);<span class="comment">//浏览器刷新插件</span></span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'reload'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    connect.server(&#123;</span><br><span class="line">        livereload: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    done();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'minifyHtml'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./test.html'</span>)  <span class="comment">//要压缩的html文件</span></span><br><span class="line">    .pipe(minifyHtml()) 			<span class="comment">//压缩html</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist'</span>))		<span class="comment">//写入dist文件夹</span></span><br><span class="line">    .pipe(connect.reload())<span class="comment">//自动刷新的关键，css合并压缩和js合并压缩都要加上这一句，就不一一举例了</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监视文件的状态并同步更新</span></span><br><span class="line">gulp.task(<span class="string">'watchs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.watch(<span class="string">'./css/*.css'</span>, gulp.series(<span class="string">'concatCss'</span>))  <span class="comment">//监视 并同步css  压缩代码</span></span><br><span class="line">    gulp.watch(<span class="string">'./js/*.js'</span>, gulp.series(<span class="string">'concatJs'</span>))     <span class="comment">//监视 并同步js   压缩代码   </span></span><br><span class="line">    gulp.watch(<span class="string">'./*.html'</span>, gulp.series(<span class="string">'minifyHtml'</span>))    <span class="comment">//监视 并同步html 压缩代码   </span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'run'</span>, gulp.series(<span class="string">'reload'</span>, <span class="string">'watchs'</span>));</span><br></pre></td></tr></table></figure>

<p><strong>*一键打包</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'bulid'</span>, gulp.parallel( <span class="comment">//一键打包生成</span></span><br><span class="line">    gulp.series(<span class="string">'concatCss'</span>),</span><br><span class="line">    gulp.series(<span class="string">'concatJs'</span>),</span><br><span class="line">    gulp.series(<span class="string">'rename'</span>),</span><br><span class="line">    gulp.series(<span class="string">'minifyHtml'</span>)</span><br><span class="line">));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>项目相关</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>笔记</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>npm的使用</title>
    <url>/2019/10/30/npm%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><strong>NPM是随同NodeJS一起安装的包管理工具，包的结构使您能够轻松跟踪依赖项和版本。</strong></p><blockquote>
<p>NPM能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p>
<p>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</p>
<p>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</p>
<p>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</p>
</blockquote><a id="more"></a>

<p><strong>项目初始化：</strong> package.json 配置文件</p>
<p><code>$ npm init -y  跳过所有提问</code></p>
<p><strong>安装包</strong></p>
<p>本地安装 <code>$ npm install 包名</code></p>
<p>全局安装<code>$ npm install 包名 -global</code></p>
<p>缩写形式<code>$ npm i 包名 -g</code></p>
<p><strong>项目依赖</strong></p>
<p> <code>$ npm install 包名 -save</code></p>
<p>项目上线需要用到的包，缩写<code>$ npm install 包名 -S (大写)</code></p>
<p><strong>开发依赖</strong></p>
<p><code>$ npm install 包名 --save-dev</code></p>
<p>开发测试需要用到的包，缩写 <code>$ npm install 包名 -D (大写)</code></p>
<p><strong>移除依赖模块</strong></p>
<p><code>$ npm uninstall 包名 -save</code></p>
<p><code>$ npm uninstall 包名 --save-dev</code></p>
<p><strong>清除缓存数据</strong></p>
<p><code>npm cache verify</code></p>
]]></content>
      <categories>
        <category>项目相关</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>npm</tag>
        <tag>操作指令</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js的初步认识</title>
    <url>/2019/10/29/nodeJs%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<h2 id="Node-js简介"><a href="#Node-js简介" class="headerlink" title="Node.js简介"></a>Node.js简介</h2><blockquote>
<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。</p>
<p>Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。</p>
<p>简单的说 Node.js 就是运行在服务端的 JavaScript</p>
<p>Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。</p>
</blockquote><a id="more"></a>
<p><strong>node.js三大特点：</strong></p>
<p><strong>1.单线程</strong></p>
<blockquote>
<p>Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。</p>
</blockquote>
<p><strong>2.非阻塞I/O(异步)</strong></p>
<blockquote>
<p>阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。</p>
<p>这是一种特别有哲理的解决方案：<strong>与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。</strong></p>
</blockquote>
<p><strong>3.事件驱动</strong></p>
<blockquote>
<p>在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件循环”机制。</p>
<p>用事件驱动来完成服务器的任务调度，用一个线程，担负起了处理非常多的任务的使命。</p>
</blockquote>
<h2 id="搭建web服务器"><a href="#搭建web服务器" class="headerlink" title="搭建web服务器"></a>搭建web服务器</h2><p><strong>总共分为四个步骤</strong></p>
<ol>
<li><p>加载http模块    </p>
</li>
<li><p>创建http服务    </p>
</li>
<li><p>服务端对象监听request 请求事件，用于监听客户端的请求    </p>
</li>
<li><p>启动http服务，监听端口</p>
</li>
</ol>
<p><strong>参考代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);		 <span class="comment">//加载http模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer();<span class="comment">//创建http服务</span></span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; <span class="comment">//服务对象监听request 请求事件，用于监听客户端的请求</span></span><br><span class="line">  <span class="comment">//req-请求对象 , res-响应对象</span></span><br><span class="line">  <span class="comment">//处理客户端请求逻辑</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'收到请求: '</span>+ req.url); <span class="comment">//用户请求地址</span></span><br><span class="line">  res.setHeader(<span class="string">"Content-type"</span>,<span class="string">"text/plain;charset=utf-8"</span>); <span class="comment">//设置文件类型</span></span><br><span class="line">  res.end(); <span class="comment">//必须结束响应，否则浏览器会被挂起</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//启动http服务，开始监听3000端口</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'服务已经启动，请访问： http://localhost:3000 或 http://127.0.0.1:3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注意点：</strong></p>
<ol>
<li>在监听request事件中，最后一定要res.end()结束响应。</li>
<li>浏览器显示中文可能是乱码，需设置响应头告诉浏览器显示时所使用的编码，要在res.end()之前设置</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">"Content-type"</span>,<span class="string">"text/plain;charset=utf-8"</span>); <span class="comment">// 响应为纯文本</span></span><br><span class="line">res.setHeader(<span class="string">"Content-type"</span>,<span class="string">"text/html;charset=utf-8"</span>);  <span class="comment">//响应为html文本</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>node.js没有根目录、没有web容器的概念！</strong></li>
</ol>
<h2 id="node-js读写文件"><a href="#node-js读写文件" class="headerlink" title="node.js读写文件"></a>node.js读写文件</h2><p><strong>读文件</strong></p>
<p><code>fs.readFile(file[, options], callback)</code></p>
<ul>
<li>参数1：要读取的文件路径，必填。   </li>
<li>参数2：读取文件时的选项，比如：文件编码utf8。选填。 </li>
<li>参数3：文件读取完毕后的回调函数，必填。</li>
</ul>
<p><strong>注意点：</strong></p>
<ul>
<li>该操作采用异步执行    </li>
<li>回调函数有两个参数，分别是err和data    </li>
<li>如果读取文件时没有指定编码，返回的是二进制数据，如指定编码utf8，会返回指定的编码数据。    </li>
<li>只要异步操作，回调函数第一个都是错误对象err优先</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载http包(nodeJS内置包)</span></span><br><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="comment">//创建服务器  </span></span><br><span class="line"><span class="keyword">let</span> server = http.createServer()</span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); <span class="comment">//引入内部模块</span></span><br><span class="line"><span class="comment">//监听服务器的请求状态(用户发送请求触发)</span></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用户发送了请求'</span>);</span><br><span class="line">    <span class="keyword">if</span> (req.url == <span class="string">'/heihei'</span>) &#123;<span class="comment">//地址可以自定义</span></span><br><span class="line">        fs.readFile(<span class="string">'./home.html'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">                res.setHeader(<span class="string">'Content-type'</span>, <span class="string">'text/html;charset=utf-8'</span>);</span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        res.writeHead(<span class="number">404</span>, &#123; <span class="string">'Content-type'</span>: <span class="string">'text/plain;charset=utf-8'</span> &#125;);</span><br><span class="line">        res.end(<span class="string">'404,页面丢失了！！！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//启动服务，监听端口 ip地址 回调函数</span></span><br><span class="line">server.listen(<span class="string">"3000"</span>, <span class="string">"10.36.147.180"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'服务已启动，请访问：10.36.147.180:3000'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>写文件</strong></p>
<p><code>fs.writeFile(file, data[, options], callback);</code></p>
<ul>
<li>参数1：要写入的文件路径，必填</li>
<li>参数2：要写入的数据，必填</li>
<li>参数3：写入文件时的选项，比如：文件编码</li>
<li>参数4：文件写入完毕后的回调函数，必填</li>
</ul>
<p><strong>注意点：</strong></p>
<ul>
<li>该操作采用异步执行    </li>
<li>如果文件存在则替换原内容    </li>
<li>默认写入的文件编码为utf8    </li>
<li>回调函数有1个参数：err，表示在写入文件的操作过程中是否出错了。    </li>
<li>如果出错了err != null，成功时 err === null    </li>
<li>写入文件（文件不存在则自动创建）</li>
</ul>
<p>writeFile写入文件是先把文件内容清空再写入，如果要追加写入的话可以使用appendFile函数</p>
<p><strong>示例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载http包(nodeJS内置包)</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); <span class="comment">//引入内部模块</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//给用户生成一个id</span></span><br><span class="line">    <span class="keyword">var</span> userid = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.radom()*<span class="number">89999</span>)+<span class="number">10000</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用户'</span>+userid);</span><br><span class="line">    res.writeHead(<span class="number">200</span>,&#123;<span class="string">"Content-Type"</span>:<span class="string">"text/html;charset=UTF8"</span>&#125;);</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">'新修改的文字'</span>;</span><br><span class="line">    <span class="comment">//参数一是当前文件路径 参数二是写入数据</span></span><br><span class="line">    <span class="comment">//参数三是文件编码	  参数四是回调函数</span></span><br><span class="line">    fs.writeFile(<span class="string">"./test.txt"</span>,str,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(err)&#123;</span><br><span class="line">           <span class="keyword">throw</span> err;</span><br><span class="line">       &#125; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'文件写入完成'</span>);</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="string">"3002"</span>, <span class="string">"10.36.147.180"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'服务已启动，请访问：10.36.147.180:3002'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>nodeJS</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>笔记</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化编程</title>
    <url>/2019/10/28/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="ES6-module"><a href="#ES6-module" class="headerlink" title="ES6 module"></a>ES6 module</h2><blockquote>
<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD  两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
</blockquote><a id="more"></a>
<p><strong>设置浏览器启用es6语法功能：（Chrome 61+，Firefox 54+）</strong></p>
<blockquote>
<ol>
<li><p>在浏览器的url中输入：<a href="chrome://flags/" target="_blank" rel="noopener">chrome://flags/</a></p>
</li>
<li><p>搜索 JavaScript 关键字</p>
</li>
<li><p>设置选项 Experimental JavaScript 为 Enable</p>
</li>
<li><p>重启浏览器后生效</p>
</li>
</ol>
</blockquote>
<p><strong>注意事项</strong></p>
<blockquote>
<ul>
<li><p>script 标签里面要加 type=”module”, 这样浏览器才会把相关的代码当作ES6的module 来对待</p>
</li>
<li><p>不能写“裸”路径，即使是同一层级下面的文件，也要加上 ‘./name.js’</p>
</li>
<li><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”。</p>
</li>
<li><p>ES6 模块功能主要由两个命令构成：export 和 import。</p>
</li>
<li><p>export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
</li>
<li><p>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。</p>
</li>
</ul>
</blockquote>
<h3 id="export-关键字"><a href="#export-关键字" class="headerlink" title="export 关键字"></a><strong>export 关键字</strong></h3><p>如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userName = <span class="string">'xiaoming'</span>;</span><br><span class="line"><span class="keyword">var</span> userSex = <span class="string">'男'</span>;</span><br><span class="line"><span class="keyword">var</span> userAge = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; userName, userSex, userAge &#125;;</span><br></pre></td></tr></table></figure>

<p>export命令除了输出变量，还可以输出对象、函数或类（class）。</p>
<p><code>export function sum(x, y) { return x + y;};</code></p>
<p>上面代码对外输出一个函数sum</p>
<p>通常情况下，export输出的变量就是本来的名字，但是可以使用<strong>as关键字</strong>重命名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  f1 <span class="keyword">as</span> test1,</span><br><span class="line">  f2 <span class="keyword">as</span> test2,</span><br><span class="line">  f2 <span class="keyword">as</span> test3</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码使用as关键字，重命名了函数f1和f2的对外接口。重命名后，f2可以用不同的名字输出两次。</p>
<p><strong>正确的写法</strong></p>
<ul>
<li><p><code>export var m = 1;</code></p>
</li>
<li><p><code>var m = 1;  export {m};</code></p>
</li>
<li><p><code>var n = 1;    export {n as m};</code></p>
</li>
<li><p><code>export function f() {};</code></p>
</li>
<li><p><code>function f() {}export {f};</code></p>
</li>
</ul>
<h3 id="import-关键字"><a href="#import-关键字" class="headerlink" title="import 关键字"></a>import 关键字</h3><p>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; userName, userSex, userAge &#125; <span class="keyword">from</span> <span class="string">'./module1.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(userName);</span><br><span class="line"><span class="built_in">console</span>.log(userSex);</span><br><span class="line"><span class="built_in">console</span>.log(userAge);</span><br></pre></td></tr></table></figure>

<p>如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。</p>
<p><code>import { userName as xm } from &#39;./module1.js&#39;;</code></p>
<p>import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。如果a是一个对象，改写a的属性是允许的。</p>
<p><code>import {a} from &#39;./xxx.js&#39;        a.foo = &#39;hello&#39;; // 合法操作</code></p>
<p><strong>import命令具有提升效果，会提升到整个模块的头部，首先执行。</strong></p>
<p>除了指定加载某些输出值，还可以使用整体加载，即用 * 指定一个对象，所有输出值都加载在这个对象上面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> obj <span class="keyword">from</span> <span class="string">'./module1.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.userName);</span><br><span class="line"><span class="built_in">console</span>.log(obj.userSex);</span><br><span class="line"><span class="built_in">console</span>.log(obj.userAge);</span><br></pre></td></tr></table></figure>

<h3 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h3><p>为了给用户提供方便，用export default命令，为模块指定默认输出。</p>
<p>默认输出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 输出</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">'./test.js'</span>; <span class="comment">// 输入</span></span><br></pre></td></tr></table></figure>

<p>正常输出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 输出</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">import</span> &#123; test &#125; <span class="keyword">from</span> <span class="string">'./test.js'</span>; <span class="comment">// 输入</span></span><br></pre></td></tr></table></figure>

<p>使用export default时，对应的import语句不需要使用大括号；</p>
<p>不使用export default时，对应的import语句需要使用大括号。</p>
<p><strong>注意：</strong></p>
<p>一个模块只能有一个默认输出，因此export default命令只能使用一次。</p>
<p>因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<h2 id="浏览器加载规则"><a href="#浏览器加载规则" class="headerlink" title="浏览器加载规则"></a>浏览器加载规则</h2><blockquote>
<p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到script&gt;标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。</p>
</blockquote>
<p><strong>浏览器两种异步加载的语法</strong></p>
<p><code>&lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt;</code></p>
<p><code>&lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt;</code></p>
<p>上面代码中，script&gt;标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p>
<p><strong>defer与async的区别</strong></p>
<p>defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；</p>
<p>async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染</p>
<p><strong>defer是“渲染完再执行”，async是“下载完就执行”。</strong></p>
<p>如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</p>
<p>浏览器加载 ES6 模块，也使用script&gt;标签，但是要加入type=”module”属性。</p>
<p>浏览器对于带有type=”module”的script&gt;，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了script&gt;标签的defer属性。</p>
<p><code>&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot; defer&gt;&lt;/script&gt;</code></p>
<h2 id="RequireJs"><a href="#RequireJs" class="headerlink" title="RequireJs"></a>RequireJs</h2><p><strong>什么是RequireJs</strong></p>
<blockquote>
<p>RequireJS是一个非常小巧的JavaScript模块载入框架，是AMD规范最好的实现者之一。</p>
<p>AMD即Asynchronous Module Definition（异步模块定义）。</p>
<p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。</p>
<p>CMD即Common Moudle Definition（通用模块定义）。</p>
<p>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</p>
</blockquote>
<p><strong>AMD和CMD相同点：</strong></p>
<blockquote>
<ul>
<li>都是异步加载模块；</li>
<li>都实现了浏览器端模块化开发的目的；</li>
<li>都倡导模块化开发理念，使前端模块化开发变得简单自然；</li>
<li>解决前端开发过程中的两大问题：<ol>
<li>文件之间的依赖问题；</li>
<li>浏览器加载多个JS文件时页面失去响应的时间过长。</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>AMD和CMD不同点：</strong></p>
<blockquote>
<ol>
<li>官方推荐的写法不同，AMD推崇依赖前置，CMD推崇依赖就近；</li>
<li>模块的执行时机不同，AMD是提前执行，CMD是延迟执行；</li>
<li>api的设计不同，AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。</li>
</ol>
</blockquote>
<p><strong>“一个模块就是一个文件”</strong></p>
<p><strong>require 用来加载依赖模块，并执行加载完后的回调函数</strong></p>
<p><code>require([&#39;moduleA&#39;, &#39;moduleB&#39;], function (a, b){ });</code></p>
<p>第一个参数是依赖模块列表，第二个参数是一个callback函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局配置</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">'js/lib'</span>,</span><br><span class="line">    paths : &#123;</span><br><span class="line">        <span class="string">"jquery"</span> : [<span class="string">"http://libs.baidu.com/jquery/2.0.3/jquery"</span>,<span class="string">"jquery-2.1.4.min"</span>],</span><br><span class="line">        <span class="string">"mytask"</span> : <span class="string">"myTask"</span>   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">require</span>([<span class="string">"jquery"</span>,<span class="string">"mytask"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$, mytask</span>)</span>&#123;</span><br><span class="line">    $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       mytask(<span class="string">"load finished"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>require.config</strong>是用来配置模块加载位置，简单点说就是<strong>引入模块并起一个别名</strong></p>
<p>配置完成还要记得在html中设置<strong>入口文件</strong></p>
<p><code>&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;</code></p>
<p><strong>define 用来定义一个模块</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(&#123;</span><br><span class="line">　 <span class="comment">// ...</span></span><br><span class="line">    key: value</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"> </span>)</span>&#123;</span><br><span class="line">　 <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">define([<span class="string">'依赖的模块路径'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">依赖模块名称</span>)</span>&#123;</span><br><span class="line">　<span class="comment">// ...</span></span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　<span class="comment">// ...</span></span><br><span class="line">　&#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">define(<span class="string">'模块名称'</span>, [<span class="string">'依赖的模块路径'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">依赖模块名称</span>)</span>&#123;</span><br><span class="line">　<span class="comment">// ...</span></span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　<span class="comment">// ...</span></span><br><span class="line">　&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2019/10/24/Promise%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote>
<p>Promise 是ES6对异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理更强大。</p>
<p>Promise 简单说就是一个容器，里面保存着一个尚未完成且预计在未来完成的异步操作。</p>
<p>Promise 是一个构造函数，用来创建一个Promise对象。</p>
<p>有了Promise对象，就可以将<strong>异步操作以同步操作的流程表达出来</strong>，避免了层层嵌套的回调函数。</p>
</blockquote><a id="more"></a>
<h3 id="Promise对象代表一个异步操作，有三种状态："><a href="#Promise对象代表一个异步操作，有三种状态：" class="headerlink" title="Promise对象代表一个异步操作，有三种状态："></a>Promise对象代表一个异步操作，有三种状态：</h3><ul>
<li>pending（进行中）</li>
<li>fulfilled（已成功）</li>
<li>rejected（已失败）</li>
</ul>
<h3 id="Promise-对象的状态改变有两种："><a href="#Promise-对象的状态改变有两种：" class="headerlink" title="Promise 对象的状态改变有两种："></a>Promise 对象的状态改变有两种：</h3><p>从 pending 变为 fulfilled</p>
<p>从 pending 变为 rejected</p>
<hr>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。</p>
<p>resolve 和 reject 是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>resolve</strong> 函数的作用是，将Promise对象的状态从“进行中”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。</p>
<p><strong>reject</strong> 函数的作用是，将Promise对象的状态从“进行中”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<hr>
<h3 id="then和catch"><a href="#then和catch" class="headerlink" title="then和catch"></a>then和catch</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//成功执行的函数（resolve）</span></span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">    </span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rej</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//失败执行的函数（reject）</span></span><br><span class="line">    <span class="built_in">console</span>.log(rej)</span><br><span class="line">    </span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">    <span class="comment">//捕获报错信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>then</strong>有两个参数，一个是成功后的回调函数，另一个是失败后的回调函数</p>
<p><strong>catch</strong>是一个用于指定发生错误的回调函数，将报错信息捕获</p>
<h3 id="使用Promise解决定时器嵌套问题"><a href="#使用Promise解决定时器嵌套问题" class="headerlink" title="使用Promise解决定时器嵌套问题"></a>使用Promise解决定时器嵌套问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装一个Promise的定时器函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPromise</span>(<span class="params">msg, time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(msg);</span><br><span class="line">                resolve();</span><br><span class="line">            &#125;, time)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//利用getPromise函数同步执行</span></span><br><span class="line"><span class="comment">//结果为： 一 二 三 完成</span></span><br><span class="line">    getPromise(<span class="string">'第一个任务'</span>, <span class="number">1000</span>)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getPromise(<span class="string">'第二个任务'</span>, <span class="number">2000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getPromise(<span class="string">'第三个任务'</span>, <span class="number">3000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getPromise(<span class="string">'完成'</span>, <span class="number">4000</span>)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域</title>
    <url>/2019/10/23/%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="Ajax跨域"><a href="#Ajax跨域" class="headerlink" title="Ajax跨域"></a>Ajax跨域</h2><blockquote>
<p>由于浏览器的同源策略，禁止ajax从一个域名请求另外一个域名上的数据。</p>
<p>浏览器的同源策略，是对JavaScript实施的安全限制</p>
</blockquote><p><strong>所谓的同源是指，域名，协议，端口都相同</strong></p><p><a href="http://image.baidu.com/search/detail?ct=503316480&z=undefined#header" target="_blank" rel="noopener">http://image.baidu.com:80/search/detail?ct=503316480&amp;z=undefined#header</a></p><a id="more"></a>


<p>URL构成：http —- 超文本传输协议</p>
<p><a href="http://image.baidu.com/" target="_blank" rel="noopener">image.baidu.com</a> —- 域名</p>
<p>80 —- 端口</p>
<p>/search/detail —- 资源目录</p>
<p>ct=503316480&amp;z=undefined —- 发送到服务器的数据</p>
<p>#header —- 锚点</p>
<h3 id="常见的跨域解决方案"><a href="#常见的跨域解决方案" class="headerlink" title="常见的跨域解决方案"></a>常见的跨域解决方案</h3><ol>
<li><strong>通过服务端语言代理请求。</strong></li>
</ol>
<p>如PHP，服务端语言php是没有跨域限制的。 让服务器去别的网站获取内容然后返回页面。</p>
<ol start="2">
<li><p><strong>jsonp跨域</strong></p>
<ul>
<li><p>jsonp跨域就是利用script标签的跨域能力请求资源</p>
</li>
<li><p>既然叫jsonp，显然目的还是json，而且是跨域获取</p>
</li>
<li><p><strong>利用js创建一个script标签，把json的url赋给script的scr属性，把这个script插入到页面里，让浏览器去跨域获取资源</strong></p>
</li>
<li><p>callback是页面存在的回调方法，参数就是想得到的json</p>
</li>
<li><p>回调方法要遵从服务端的约定一般是用 callback 或者 cb</p>
</li>
<li><p><strong>jsonp只针对get请求</strong></p>
</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">OScript = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);<span class="comment">//创建script标签 </span></span><br><span class="line">OScript.src = <span class="string">'http://suggestion.baidu.com/su?wd='</span> + <span class="keyword">this</span>.value + <span class="string">'&amp;cb=myCallback'</span>;</span><br><span class="line"><span class="comment">//把数据地址赋值给src</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(OScript);<span class="comment">//添加到页面</span></span><br></pre></td></tr></table></figure>



<ol start="3">
<li><strong>CORS 跨域资源共享(xhr2)</strong></li>
</ol>
<p>实现CORS通信的关键是服务端，只要服务端实现了CORS接口，就可以跨源通信</p>
<p>实现CORS并不难，只需服务端做一些设置即可：</p>
<p><code>&lt;?phpheader(&quot;Access-Control-Allow-Origin:*&quot;); // 允许任何来源</code></p>
<h3 id="jQuery使用跨域"><a href="#jQuery使用跨域" class="headerlink" title="jQuery使用跨域"></a>jQuery使用跨域</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=<span class="string">"text"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ipt"</span>&gt;</span><br><span class="line">&lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"btn"</span>&gt;请求jsonp数据&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;ul class="list"&gt;&lt;/u</span>l&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">"../jquery-1.12.4.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(<span class="string">'.btn'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: <span class="string">'http://suggestion.baidu.com/su'</span>, <span class="comment">// 输入接口地址</span></span><br><span class="line">            type: <span class="string">'get'</span>, 		<span class="comment">//必须为get类型</span></span><br><span class="line">            data: <span class="string">'wd='</span> + $(<span class="string">'.ipt'</span>).val(),</span><br><span class="line">            cache: <span class="literal">false</span>,</span><br><span class="line">            dataType: <span class="string">'jsonp'</span>,  <span class="comment">//修改为jsonp格式</span></span><br><span class="line">            jsonp: <span class="string">'cb'</span>,        <span class="comment">//传入回调函数</span></span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">json</span>) </span>&#123;</span><br><span class="line">                $.each(json.s, <span class="function"><span class="keyword">function</span> (<span class="params">index, val</span>) </span>&#123;</span><br><span class="line">                    $(<span class="string">'.list'</span>).append(<span class="string">'&lt;li&gt;'</span> + val + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                alert(<span class="string">'请求失败'</span>)</span><br><span class="line">                <span class="built_in">console</span>.log(err.status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie与HTML5本地存储</title>
    <url>/2019/10/23/cookie%E4%B8%8EHTML5%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h2 id="cookie是什么"><a href="#cookie是什么" class="headerlink" title="cookie是什么"></a>cookie是什么</h2><blockquote>
<p>cookie是浏览器提供的一种机制，可以由JavaScript对其进行操作(设置、读取、删除)cookie是一种会话跟踪技术，是存储于访问者计算机中的一小块数据</p>
<p>会话：用户进入网站，开始浏览信息到关闭浏览器的过程，就称之为是一次会话会话跟踪技术：浏览器和服务器之间在进行多次请求间共享数据的过程，就称为会话跟踪技术</p>
</blockquote><a id="more"></a>
<p><strong>cookie的特性</strong>（服务端运行）</p>
<blockquote>
<ul>
<li>cookie可以实现跨页面全局变量</li>
<li>cookie可以跨越同域名下的多个网页，但不能跨域使用</li>
<li>cookie会随着HTTP请求发送给服务器</li>
<li>cookie会存储于访问者的计算机中</li>
<li>同一个网站中所有页面共享一套cookie</li>
<li>可以设置有效期限</li>
<li>存储空间为4KB左右</li>
<li><strong>cookie过期会自动消失</strong></li>
</ul>
</blockquote>
<p><strong>cookie的应用场景</strong></p>
<blockquote>
<ul>
<li>会话状态管理（如用户登录状态、购物车等）</li>
<li>个性化设置（保存用户设置的样式等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
</blockquote>
<p><strong>cookie的缺点</strong></p>
<blockquote>
<ol>
<li>cookie可能被禁用</li>
<li>cookie与浏览器相关，不能互相访问</li>
<li>cookie可能被用户删除</li>
<li>cookie安全性不够高</li>
<li>cookie会随着HTTP请求发送给服务器</li>
<li>cookie存储空间很小(只有4KB左右)</li>
<li>cookie操作麻烦，没有方便的API</li>
</ol>
</blockquote>
<hr>
<p><strong>操作cookie</strong></p>
<p>设置cookie:</p>
<p>如果要改变值，则需要重新赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"user=zhangsan"</span>;</span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"pass=123456"</span>;</span><br></pre></td></tr></table></figure>

<p>设置有效期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var d = new Date();</span><br><span class="line">d.setDate(d.getDate()+3); //按天数设置</span><br><span class="line">document.cookie=&quot;user3=xd; expires=&quot;+d;</span><br></pre></td></tr></table></figure>

<p>读取cookie</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var cookies = document.cookie;</span><br></pre></td></tr></table></figure>

<p>删除cookie:</p>
<p>可以将有效期设为一个已经过去的时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var d=new Date();</span><br><span class="line">d.setDate(d.getDate()-1);</span><br><span class="line">document.cookie=&quot;user1=xh; expires=&quot;+d;</span><br></pre></td></tr></table></figure>



<h2 id="HTML5本地存储"><a href="#HTML5本地存储" class="headerlink" title="HTML5本地存储"></a>HTML5本地存储</h2><blockquote>
<p>H5本地存储有 localStorage 与 sessionStorage 两种</p>
</blockquote>
<p><strong>优点：</strong></p>
<ul>
<li>更大的存储空间，有5MB左右</li>
<li>不会随HTTP请求发送给服务器</li>
<li>有方便的API操作</li>
<li>移动端普及高</li>
</ul>
<p><strong>操作：</strong></p>
<p> <strong>保存或设置数据</strong></p>
<p><code>localStorage.setItem(key , value)</code> </p>
<p>如果key已经存在，则覆盖key对应的value</p>
<p>如果不存在则添加key与value</p>
<p>  <strong>获取key对应的value</strong></p>
<p><code>localStorage.getItem(key)</code></p>
<p>  <strong>获取指定下标位置的key</strong></p>
<p><code>localStorage.key(index)</code></p>
<p><strong>获取数据条数（长度）</strong></p>
<p><code>localStorage.length</code></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">localStorage.clear() 将同域名下的所有数据都清空</span><br><span class="line"></span><br><span class="line">localStorage.removeItem(&apos;key&apos;) 删除某个键值对</span><br><span class="line"></span><br><span class="line">sessionStorage 为临时性保存数据，当页面关闭就会消失</span><br><span class="line">sessionStorage 不能跨页面访问，只局限在当前的标签页</span><br><span class="line">sessionStorage 各种操作与 localStorage 一样</span><br></pre></td></tr></table></figure>



<h2 id="JSON转换"><a href="#JSON转换" class="headerlink" title="JSON转换"></a>JSON转换</h2><blockquote>
<p>目前 JavaScript 使用非常多的 json 格式</p>
<p>可以使用 JSON.stringify() 将 json对象 转为 json字符串</p>
<p>然后把 json字符串 存储在 cookie 或 localStorage 里面</p>
<p>读取出来以后使用 JSON.parse() 将 json字符串 转为 json对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = &#123;<span class="string">"name1"</span>:<span class="string">"jack"</span>,<span class="string">"name2"</span>:<span class="string">"lily"</span>&#125;;</span><br><span class="line">localStorage.setItem(<span class="string">"user"</span>,<span class="built_in">JSON</span>.stringify(jsonObj)); <span class="comment">// 存储</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonObj = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">"user"</span>)); <span class="comment">// 读取</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>AJax的交互和异同</title>
    <url>/2019/10/23/aJax%E7%9A%84%E4%BA%A4%E4%BA%92%E5%8F%8A%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<blockquote>
<p>Ajax是什么？</p>
<p>Ajax是一种在无需加载整个网页的情况下，能够更新部分网页的技术（局部刷新）</p>
<p>通俗的来说，Ajax就是JS通过一个网址去加载数据，这个过程用户是不可见的，传统的网页（不使用Ajax）如果需要更新内容，必须重新加载整个网页</p>
</blockquote><a id="more"></a>
<h2 id="Ajax怎么使用"><a href="#Ajax怎么使用" class="headerlink" title="Ajax怎么使用"></a>Ajax怎么使用</h2><p><strong>ajax请求分4个步骤</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建XMLHttpRequest对象(数据交互对象)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);<span class="comment">//ie 5 6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.打开与服务器的链接</span></span><br><span class="line">xhr.open(<span class="string">'post'</span>,<span class="string">'xxx.php'</span>,<span class="literal">true</span>);<span class="comment">//解决缓存 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.发送请求</span></span><br><span class="line"><span class="comment">// xhr.send(null);//get请求</span></span><br><span class="line">xhr.send(<span class="string">'can='</span>+ele.value);<span class="comment">//post请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.等待服务的响应</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// console.log(xhr.readyState);//2 3 4</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;<span class="comment">//请求完成</span></span><br><span class="line">        <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;<span class="comment">//请求成功</span></span><br><span class="line">            <span class="keyword">var</span> json = <span class="built_in">JSON</span>.parse(xhr.responseText);<span class="comment">//转成json对象</span></span><br><span class="line">            con.innerHTML = <span class="string">''</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">'请求失败，'</span> + xhr.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="GET和POST之间的区别"><a href="#GET和POST之间的区别" class="headerlink" title="GET和POST之间的区别"></a>GET和POST之间的区别</h2><blockquote>
<ol>
<li>get参数通过url传递，post放在请求体（request  body）中；</li>
<li>get请求在url传递的参数有长度限制，而post没有；</li>
<li>get没有post安全，因为参数直接显示在url地址中，不能传递敏感数据</li>
<li>get请求浏览器会主动缓存，而post不会；</li>
<li>get请求参数会保存在浏览历史纪录，而post请求不会；</li>
</ol>
</blockquote>
<hr>
<h2 id="Ajax的函数封装"><a href="#Ajax的函数封装" class="headerlink" title="Ajax的函数封装"></a>Ajax的函数封装</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">option</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建XMLHttpRequest对象(数据交互对象)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);<span class="comment">//ie 5 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// data -&gt; 'a=123&amp;b=456'</span></span><br><span class="line">    <span class="keyword">if</span> (option.type == <span class="string">'get'</span> || option.type == <span class="string">'GET'</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.打开与服务器的链接</span></span><br><span class="line">        xhr.open(option.type,option.url + <span class="string">'?'</span>+ option.data + <span class="string">'&amp;_='</span>+<span class="keyword">new</span> <span class="built_in">Date</span>().getTime(),<span class="literal">true</span>);<span class="comment">//解决缓存</span></span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        xhr.send(<span class="literal">null</span>);<span class="comment">//get请求</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option.type == <span class="string">'post'</span> || option.type == <span class="string">'POST'</span>)&#123;</span><br><span class="line">        <span class="comment">// 2.打开与服务器的链接</span></span><br><span class="line">        xhr.open(option.type,option.url,<span class="literal">true</span>);<span class="comment">//解决缓存</span></span><br><span class="line">        <span class="comment">// 模拟表单form的post方式提交数据，在send之前设置</span></span><br><span class="line">        xhr.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        xhr.send(option.data);<span class="comment">//post请求</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">'目前只支持get和post请求方式!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.等待服务的响应</span></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// console.log(xhr.readyState);//2 3 4</span></span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;<span class="comment">//请求完成</span></span><br><span class="line">            <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;<span class="comment">//请求成功</span></span><br><span class="line">                option.success(xhr.responseText);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//请求失败</span></span><br><span class="line">                option.failed(xhr.status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用Ajax</span></span><br><span class="line">    ajax(&#123;</span><br><span class="line">        url: <span class="string">'./data/post.php'</span>,</span><br><span class="line">        type: <span class="string">'post'</span>,</span><br><span class="line">        data: <span class="string">'age='</span>+ ipt.value,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> json = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">            con.innerHTML = <span class="string">'姓名：'</span>+json.name;</span><br><span class="line">        &#125;,</span><br><span class="line">        failed: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">'请求失败'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="jQuery的Ajax调用"><a href="#jQuery的Ajax调用" class="headerlink" title="jQuery的Ajax调用"></a>jQuery的Ajax调用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">"study/data/get.php"</span>,</span><br><span class="line">    type: <span class="string">'get'</span>,</span><br><span class="line">    data: <span class="string">'age=28'</span>,</span><br><span class="line">    cache: <span class="literal">false</span>,       <span class="comment">//是否使用缓存</span></span><br><span class="line">    dataType: <span class="string">'json'</span>,   <span class="comment">//转换成json或者text格式</span></span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        $(<span class="string">'.con'</span>).text(data.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    $.<span class="keyword">get</span>('study/data/<span class="keyword">get</span>.php', 'age=18', function (json) &#123;</span><br><span class="line">        $(<span class="string">'.con'</span>).text(json.name)</span><br><span class="line">    &#125;, <span class="string">'json'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>笔记</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown语法教程</title>
    <url>/2019/10/21/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>MarkDown是一种纯文本格式的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>下面让我们一起来快速学习一下MarkDown的语法吧</p>
</blockquote><h3 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h3><p>一般是在标题文字前面加上#来表示</p><p>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p><a id="more"></a>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h3><ul>
<li><strong>加粗</strong></li>
</ul>
<p>要加粗的文字左右分别用两个*号包起来</p>
<ul>
<li><strong>斜体</strong></li>
</ul>
<p>要倾斜的文字左右分别用一个*号包起来</p>
<ul>
<li><strong>斜体加粗</strong></li>
</ul>
<p>要倾斜和加粗的文字左右分别用三个*号包起来</p>
<ul>
<li><strong>删除线</strong></li>
</ul>
<p>要加删除线的文字左右分别用两个~~号包起来</p>
<p>代码示例：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**这是加粗的文字**</span></span><br><span class="line"><span class="emphasis">*这是倾斜的文字*</span></span><br><span class="line"><span class="strong">***这是斜体加粗的文字**</span>*</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h3><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;，可以加任意个&gt;</p>
<p>示例：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h3><p>三个或者三个以上的 - 或者 * 都可以。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line"><span class="emphasis">***</span></span><br><span class="line"><span class="strong">*****</span></span><br></pre></td></tr></table></figure>

<p>四行代码的效果都是一样的。</p>
<hr>
<h3 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片alt</span>](<span class="link">"图片地址" "图片title"</span>)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h3><p>示例</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">超链接名</span>](<span class="link">超链接地址 "超链接title"</span>)</span><br><span class="line">title可以不加，看个人需求</span><br><span class="line"></span><br><span class="line">[<span class="string">百度</span>](<span class="link">https://baidu.com</span>)</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h3><ul>
<li><strong>无序列表</strong></li>
</ul>
<p>语法：</p>
<p>无序列表用 - + * 任何一种都可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>有序列表</strong></li>
</ul>
<p>数字加点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.列表内容</span><br><span class="line">2.列表内容</span><br><span class="line">3.列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>列表嵌套</strong></li>
</ul>
<p><strong>第二级列表按下tab键缩进</strong></p>
<ul>
<li>一级列表<ul>
<li>二级列表</li>
</ul>
</li>
</ul>
<hr>
<h3 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h3><p>语法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 姓名 | 技能 | 排行 |</span><br><span class="line">| ---- | :--: | ---: |</span><br><span class="line">| 刘备 |  哭  | 大哥 |</span><br><span class="line">| 关羽 |  打  | 二哥 |</span><br><span class="line">| 张飞 |  骂  | 三弟 |</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h3><p>语法</p>
<p>单行代码：代码之间分别用一个反引号包起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`代码内容`</span><br></pre></td></tr></table></figure>

<p>代码块：使用三个反引号回车即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(```)</span><br><span class="line">	代码</span><br><span class="line">	代码</span><br><span class="line">	代码</span><br><span class="line">	</span><br><span class="line">注：这里为了三个反引号不被浏览器转义加上了括号，实际上不需要添加</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>常用</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建博客</title>
    <url>/2019/10/19/Hexo%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<blockquote>
<p>使用Hexo快速搭建一个自己的专属博客</p>
<p>搭建要求：node.js，git bash, github仓库</p>
<p>很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行；</p>
</blockquote><a id="more"></a>
<p><strong>安装之前的准备</strong></p>
<blockquote>
<ul>
<li><p>有一个github账号，这是必要的</p>
</li>
<li><p>安装了node.js  npm  并且了解基本终端指令</p>
</li>
<li><p>最好有一个git bash</p>
</li>
</ul>
</blockquote>
<p><strong>开始安装hexo</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure>

<p><strong>初始化</strong></p>
<p>在电脑任意地方新建一个文件夹，用于存放博客文件</p>
<p>找到当前文件夹的地址进行初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>

<p><strong>生成文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"新文档"</span></span><br></pre></td></tr></table></figure>

<p><strong>生成静态文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p><strong>发送到本地端口服务器</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>此时已经生成了本地端口号，默认都是localhost:4000</p>
<p>输入端口，成功后会出现一个默认的博客页面</p>
<p><strong>部署网站</strong></p>
<p>将博客部署到github上面，以后就可以通过github域名查看博客</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p><strong>清除缓存和已生成的静态文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>

<p><strong>ERROR Deployer not found: git 解决方法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>语法</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
