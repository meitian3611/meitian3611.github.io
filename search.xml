<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>小程序-2</title>
    <url>/2020/01/13/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-2/</url>
    <content><![CDATA[<h2 id="构建npm"><a href="#构建npm" class="headerlink" title="构建npm"></a>构建npm</h2><ol>
<li><code>npm init</code></li>
<li>安装所需要的包（库）</li>
<li>本地设置中，开启npm的模块</li>
<li>工具栏中点击构建npm</li>
</ol><h2 id="使用字体图标"><a href="#使用字体图标" class="headerlink" title="使用字体图标"></a>使用字体图标</h2><ol>
<li>下载到本地目录</li>
<li>使用线上地址<ol>
<li>下载阿里图标库本地Unicode代码</li>
<li>将下载的iconfont.css 的代码复制到小程序项目的 app.wxss 中</li>
<li>将app.wxss 中的 font-face 的代码使用线上的 font-face 代码进行替换</li>
<li>正常使用 <code>&lt;view class=&quot;iconfont iconyingyuan&quot;&gt;&lt;/view&gt;</code></li>
</ol>
</li>
</ol><a id="more"></a>

<h2 id="使用-Vant-Weapp"><a href="#使用-Vant-Weapp" class="headerlink" title="使用 Vant Weapp"></a>使用 Vant Weapp</h2><ol>
<li><p>安装组件库  <code>npm i @vant/weapp -S --production</code></p>
</li>
<li><p>构建 npm 包</p>
</li>
<li><p>全局或局部引入需要使用的组件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">// app.json</span><br><span class="line">"usingComponents": &#123;</span><br><span class="line">  "van-button": "@vant/weapp/button"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h2><ol>
<li>创建组件<ol>
<li>在根目录创建一个组件目录components</li>
<li>创建一个Demo目录</li>
<li>在Demo目录创建一个component文件类型的Demo文件</li>
</ol>
</li>
<li>注册组件，使用方法和 Vant引入组件 一样</li>
<li>使用组件</li>
</ol>
<h2 id="组件的通信"><a href="#组件的通信" class="headerlink" title="组件的通信"></a>组件的通信</h2><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo.js</span></span><br><span class="line">properties: &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      value: <span class="string">'我是demo组件'</span></span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- demo.wxml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.wxml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-demo</span> <span class="attr">name</span>=<span class="string">"我是修改后的demo组件"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-demo</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- demo.wxml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">"son"</span>&gt;</span>点击修改父级 name<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo.js</span></span><br><span class="line">methods: &#123;</span><br><span class="line">    son() &#123;</span><br><span class="line">      <span class="keyword">this</span>.triggerEvent(<span class="string">'abc'</span>,<span class="string">'子修改父级'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.wxml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-demo</span> <span class="attr">name</span>=<span class="string">"&#123;&#123;name&#125;&#125;"</span> <span class="attr">bindabc</span>=<span class="string">"father"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-demo</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: <span class="string">'index的name'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  father(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      name: e.detail</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>使用方法</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序-1</title>
    <url>/2020/01/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-1/</url>
    <content><![CDATA[<p>详细文档请参考官网   <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener">文档链接</a></p><h2 id="一，基本语法"><a href="#一，基本语法" class="headerlink" title="一，基本语法"></a>一，基本语法</h2><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><ol>
<li>在开始标签与结束标签中绑定直接使用 双花括号</li>
<li>绑定属性仍然使用双花括号</li>
</ol><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><blockquote>
<p>wx:for</p>
</blockquote><ol>
<li><p>默认情况下，循环的每一项是使用 item 来接收的。如果需要修改使用 wx:for-item=”xxx”</p>
</li>
<li><p>默认情况下，循环的每一项的下标是 index 来接收的。如果需要修改使用 wx:for-index=”yyy</p>
</li>
<li><p>需要提供 wx:key，如果数据由唯一值，例如id，那么直接设置 wx:key 为这个属性的名字，如果没有唯一值，则设置为 *this 即可</p>
</li>
</ol><a id="more"></a>



<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;list&#125;&#125;"</span> <span class="attr">wx:for-item</span>=<span class="string">"abc"</span> <span class="attr">wx:key</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span>&gt;</span>&#123;&#123;abc.name&#125;&#125; - &#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><blockquote>
<p>wx:if —– wx:else —— wx:elif </p>
</blockquote>
<ol>
<li>小程序中没有wx:show，但有一个作用相反的公共 hidden 属性</li>
<li>wx:if 和 hidden 的区别<ol>
<li>wx:if 才是真真的条件渲染，而 hidden 只是简单的控制 display style</li>
<li>wx:if 有配套的 wx:else wx:elif， 而 hidden 没有</li>
<li>wx:if 可以配合 block 使用，而 hidden 不可以</li>
<li>wx:if 有更高的切换开销，hidden 有更高的初始渲染开销</li>
<li>频繁切换使用 hidden。否则使用 wx:if</li>
</ol>
</li>
</ol>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><blockquote>
<p>WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用</p>
</blockquote>
<ol>
<li><p>定义模板, 要设置 name 属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">"xxx"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用模板，要设置 is 属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">"xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引入在别的 wxml 中定义的模板，需要使用 import 标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">src</span>=<span class="string">"xxx.wxml"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用模板时，可以设置 data 属性来给模板传递参数增加模板的复用性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 模板文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>demo ---- &#123;&#123; name &#125;&#125; - &#123;&#123; age &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入模板文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">src</span>=<span class="string">"/templates/demo.wxml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">"demo"</span> <span class="attr">data</span>=<span class="string">"&#123;&#123;msg:'张三', age:20&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote>
<p>wxml中提供了两个标签可以去引入别的 wxml 中的内容</p>
</blockquote>
<ol>
<li>import 只能用于引入 template 模板</li>
<li>include 只能用于引入wxml 中的视图，不能引入template内容</li>
</ol>
<h2 id="二，生命周期"><a href="#二，生命周期" class="headerlink" title="二，生命周期"></a>二，生命周期</h2><blockquote>
<p>在小程序中，含有两种生命周期，APP生命周期，Page生命周期</p>
<p>通俗来说就是全局的生命周期和当前页面的生命周期</p>
</blockquote>
<h3 id="App"><a href="#App" class="headerlink" title="App"></a>App</h3><ul>
<li>onLaunch        小程序的初始化，每次加载小程序只执行一次</li>
<li>onShow           监听小程序的显示</li>
<li>onHide            监听小程序的隐藏</li>
</ul>
<h3 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h3><ul>
<li>onLoad           监听页面的加载，初次进入当前页面就会执行</li>
<li>onShow          监听页面的显示，每次进入当前页面都会执行</li>
<li>onReady         监听页面的渲染完成，初次进入当前页面就会执行</li>
<li>onHide           监听页面的隐藏，每次离开当前页面都会执行</li>
<li>onUnload      监听页面的卸载，只有当前页面被<strong>重定向</strong>或<strong>关闭</strong>才会执行<ul>
<li>wx.redirectTo      ||     navigator    open-type=”redirect”</li>
<li>wx.navigateBack ||    navigator    open-type=”navigateBack”</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重定向后，没有返回上一级按钮，页面已经被卸载，再次打开需要执行 onLoad  onReady</span></span><br><span class="line"></span><br><span class="line">&lt;navigator url=<span class="string">"/pages/demo/demo"</span> open-type=<span class="string">"redirectTo"</span>&gt;重定向页面&lt;<span class="regexp">/navigator&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button bindtap=<span class="string">"handleClick"</span>&gt;重定向&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ </span></span><br><span class="line"><span class="regexp">  handleClick()&#123;</span></span><br><span class="line"><span class="regexp">    wx.redirectTo(&#123;</span></span><br><span class="line"><span class="regexp">      url: '/</span>pages/demo/demo<span class="string">',</span></span><br><span class="line"><span class="string">    &#125;)&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>第一次打开小程序</p>
<blockquote>
<p>onLaunch  =&gt;  App onShow  =&gt;  Page onLoad  =&gt; Page onShow  =&gt; Page onReady</p>
</blockquote>
<p>切换到后台</p>
<blockquote>
<p>Page onHide  =&gt;  App onHide</p>
</blockquote>
<p>切换回小程序界面</p>
<blockquote>
<p>App onShow  =&gt;  Page onShow</p>
</blockquote>
<h2 id="多页面共享数据"><a href="#多页面共享数据" class="headerlink" title="多页面共享数据"></a>多页面共享数据</h2><ol>
<li>使用小程序的本地存储  —  storage</li>
<li>在 App 中定义，然后其它页面通过 getApp() 函数获取数据实现多页面共享</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// APP.js</span></span><br><span class="line">App(&#123;</span><br><span class="line">    globalData: &#123;</span><br><span class="line">    name: <span class="string">'张三'</span></span><br><span class="line">  &#125;&#125;)</span><br><span class="line"><span class="comment">// demo.js</span></span><br><span class="line">Page(&#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">       name: getApp().globalData.name</span><br><span class="line">  &#125;&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>组件</tag>
        <tag>前端</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>NATAPP内网穿透</title>
    <url>/2020/01/07/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h2 id="什么是内网穿透"><a href="#什么是内网穿透" class="headerlink" title="什么是内网穿透 ?"></a>什么是内网穿透 ?</h2><blockquote>
<p>对于前端工程师来说，内网穿透就是可以实现内网与外网之间通过natapp隧道打通，让内网的数据可以使用外网获取，例如 Vue 脚手架的 127.0.0.1:8080 端口，通常只有本地才能预览，但是使用natapp进行内网穿透，就可以实现一个所有人可访问的域名，类似于项目上线，但是内网穿透必须保证服务开启状态，所有用户才能进行访问。</p>
</blockquote><a id="more"></a>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><ol>
<li><p>进入官网  <a href="https://natapp.cn/" target="_blank" rel="noopener">官网链接</a></p>
</li>
<li><p>点击客户端下载与自己电脑对应的版本即可</p>
</li>
<li><p>下载本地配置文件config.ini   <a href="https://natapp.cn/article/config_ini" target="_blank" rel="noopener">下载链接</a></p>
</li>
<li><p>将config.ini文件放在 客户端natapp.exe同级目录下</p>
</li>
<li><p>在官网注册账号并购买免费隧道</p>
</li>
</ol>
<p><img src="https://i.loli.net/2020/01/07/ANzSWxbPsymgDdK.png" alt="TIM截图20200107175552.png"></p>
<ol start="6">
<li><p>复制自动生成的 authtoken ，打开config.ini 文件 找到 authtoken=</p>
</li>
<li><p>将复制的内容粘贴在 authtoken= 后保存退出即可</p>
</li>
<li><p>点击上图的配置按钮修改成自己项目生成的端口号</p>
</li>
</ol>
<p><img src="https://i.loli.net/2020/01/07/7Z1PNF4VHxQCXYz.png" alt="TIM截图20200107180324.png"></p>
<ol start="9">
<li>点击natapp.exe 运行  浏览器输入生成的域名即可访问本地的项目</li>
</ol>
<p><img src="https://i.loli.net/2020/01/07/B5XHMR1sPVKL3Tt.png" alt="success.png"></p>
]]></content>
      <categories>
        <category>进阶提升</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>少数</tag>
        <tag>服务端</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux</title>
    <url>/2019/12/25/Redux/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Redux 是 javascript 状态管理器，和 Vuex 相似，但又不同于 Vuex</p>
</blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<ol>
<li>npm install –save redux  ||   yarn add redux</li>
<li>创建 src/store/index.js 用来实例化仓库</li>
</ol>
</blockquote><a id="more"></a>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** src/store/index.js **/</span></span><br><span class="line"><span class="comment">// 1. 引入 redux 的 createStore 方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="comment">// 2. 定义 renducer 纯函数</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'reducer'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 调用 createStore() 传入 reducer 函数 并设置 redux devtools 插件</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">    reducer, <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__())</span><br><span class="line"><span class="comment">// 4. 导出仓库的实例对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>



<h2 id="Redux的三大原则"><a href="#Redux的三大原则" class="headerlink" title="Redux的三大原则"></a>Redux的三大原则</h2><ul>
<li><strong>单个数据源</strong>  整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在唯一的store中</li>
<li><strong>state 是只读的</strong>  唯一改变 state 的方法就是触发 action ，action是一个用于描述已发生事件的普通对象</li>
<li><strong>使用纯函数来执行修改</strong>  为了描述 action 如何改变 state tree ，你需要编写 reducers</li>
</ul>
<blockquote>
<p>纯函数</p>
<ol>
<li>不会修改参数</li>
<li>会自动接收上一次仓库的 state  action数据</li>
<li>默认自动触发一次</li>
<li>一定要返回，返回的内容就是仓库的最新 state 数据</li>
</ol>
</blockquote>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>一个用于描述要做什么动作的普通对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: <span class="string">'ADD_TODO'</span>, <span class="comment">// type字段必须</span></span><br><span class="line">    text: <span class="string">'吃饭'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><p>根据 Action 动作的不同，对仓库的数据进行处理的一个<strong>纯函数</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> todoApp = <span class="function">(<span class="params">state,action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'ADD_TODO'</span>:</span><br><span class="line">            <span class="keyword">return</span> [</span><br><span class="line">                ...state,</span><br><span class="line">                &#123;</span><br><span class="line">                    id: action.id,</span><br><span class="line">                    text: action.text,</span><br><span class="line">                    completed: fasle</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">            dafault:</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>仓库，存放状态（state）将 action 和reducers 联系起来的东西</p>
<ul>
<li>getState() 方法 可以获取 state</li>
<li>dispatch(action) 方法可以更新state</li>
<li>subscribe(listener) 注册监听器  返回的函数可以注销监听器</li>
</ul>
<h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save react-redux || yarn add react-redux</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不需要在所有的组件文件引入 store 了，入口文件引入一次并通过 react-redux 的 Provider 组件传递进入</p>
<p>仓库数据发生变化，不需要我们手动监听和取消监听了</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------ src/index.js --------</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;, </span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>哪个组件需要使用仓库的数据，就用 react-redux 的 connect() 高阶函数对哪个组件进行包装。</p>
<p>返回的是一个容器组件  connect(mapStateToProps, mapDispatchToProps) (UI组件)</p>
</blockquote>
<h3 id="mapStateToProps-state-ownProps"><a href="#mapStateToProps-state-ownProps" class="headerlink" title="mapStateToProps(state, ownProps)"></a>mapStateToProps(state, ownProps)</h3><p>处理仓库的 state 数据给到 UI组件的 props 上面</p>
<blockquote>
<ol>
<li>是个函数，会自动接收到 仓库的 state 数据。</li>
<li>需要返回一个对象，返回的对象就是 UI组件的 一部分 props 数据</li>
<li>仓库的数据如果发生变化，这个函数会重新执行</li>
</ol>
</blockquote>
<h3 id="mapDispatchToProps-state-ownProps"><a href="#mapDispatchToProps-state-ownProps" class="headerlink" title="mapDispatchToProps(state, ownProps)"></a>mapDispatchToProps(state, ownProps)</h3><p>处理仓库的 dispatch 数据给到 UI组件的 props 上面</p>
<blockquote>
<ol>
<li>是个函数，会自动接收到 仓库的 dispatch 方法</li>
<li>需要返回一个对象，返回的对象就是 UI组件的 一部分 props 数据</li>
</ol>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ------  src/views/PageA.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>  <span class="comment">// 引入connect即可</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">	(state) =&gt; &#123;&#125;,</span><br><span class="line">	(dispatch) =&gt; &#123;&#125;</span><br><span class="line">)(PageA)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>框架</tag>
        <tag>核心</tag>
      </tags>
  </entry>
  <entry>
    <title>state与受控组件</title>
    <url>/2019/12/25/state%E4%B8%8E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="state的一些额外情况"><a href="#state的一些额外情况" class="headerlink" title="state的一些额外情况"></a>state的一些额外情况</h2><blockquote>
<ul>
<li>初始化是放在 构造函数的</li>
<li>如果代码支持 public class filed 的实验语法 那么可以直接进行初始化 state</li>
<li>不可以直接对 state 进行修改，要修改一定是使用 setState()函数</li>
</ul>
</blockquote><a id="more"></a>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">"hello"</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">render() &#123;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;<span class="keyword">this</span>.state.msg&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">                </span></span><br><span class="line"><span class="regexp">                this.setState(&#123;</span></span><br><span class="line"><span class="regexp">                    msg: 'world'</span></span><br><span class="line"><span class="regexp">                &#125;);</span></span><br><span class="line"><span class="regexp">                </span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/  console.log(this.state.msg)结果为hello 页面文字是world，但是数据未改变 </span></span><br><span class="line"><span class="regexp">            &#125;&#125;</span></span><br><span class="line"><span class="regexp">          &gt;点击修改msg&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Hello /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>setState() 这个函数可能是异步的。会导致视图刷新，但是数据没有更新，如果要立刻得到新的数据可以给 setState 传递第二个参数，立即执行函数</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了解决上面的数据更新问题 应该将代码进行变动</span></span><br><span class="line"><span class="keyword">this</span>.setState(</span><br><span class="line">&#123;</span><br><span class="line">    msg : <span class="string">'world'</span></span><br><span class="line">&#125;,</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.setState.msg) <span class="comment">// 打印结果为 world 数据成功变化</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在一次周期中，多次 setState() 调用会进行合并</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;;</span><br><span class="line">	render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;</span></span><br><span class="line"><span class="regexp">                        </span></span><br><span class="line"><span class="regexp">             	 for (let i = 0; i &lt; 5; i++) &#123;</span></span><br><span class="line"><span class="regexp">            	this.setState(&#123;</span></span><br><span class="line"><span class="regexp">                count: this.state.count + 1  /</span><span class="regexp">/ 合并为一条 只会进行+1操作</span></span><br><span class="line"><span class="regexp">                    </span></span><br><span class="line"><span class="regexp">       &#125;);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">   &#125;&gt;点击增加数值 &lt;/</span>button&gt;</span><br><span class="line">     &lt;<span class="regexp">/div&gt;)&#125;</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;Hello /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>倘若想要不合并，serState的第一个参数传递为一个函数对象的形式，然后这个函数就会自动接收两个参数 prevState props</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: prevState.count + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h2><blockquote>
<p>表单元素的value值如果完全由数据来控制的话，那么这个元素可以叫做受控组件</p>
</blockquote>
<blockquote>
<p> 受控组件的值如果要发生变化，需要监听 onChange事件。在事件处理函数去修改数据</p>
<p> radio 是通过 checked 来控制</p>
<p> checkbox 也是通过 checked 来控制</p>
</blockquote>
<h2 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h2><blockquote>
<p>表单元素不是由数据（value）来控制的</p>
</blockquote>
<blockquote>
<p>需要使用 ref 进行取值</p>
<p>ref 有两种写法：1. 字符串 2. 函数，函数会自动接收到这个元素的DOM对象/</p>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>组件</tag>
        <tag>state</tag>
      </tags>
  </entry>
  <entry>
    <title>Hook</title>
    <url>/2019/12/24/Hook/</url>
    <content><![CDATA[<blockquote>
<p> Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性 </p>
</blockquote><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><blockquote>
<p>返回一个自己指定的属性，以及更新原数据的函数</p>
</blockquote><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [name, setName] = useState(<span class="string">"张三"</span>)</span><br></pre></td></tr></table></figure><a id="more"></a>



<p>使用示例</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [name, setName] = useState(<span class="string">"张三"</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    	&lt;div&gt;</span><br><span class="line">        	&lt;p&gt;&#123; name &#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123; () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">                setName('李四')</span></span><br><span class="line"><span class="regexp">             &#125;&#125;&gt;修改name&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><blockquote>
<p>默认情况下，effect 会在每轮组件渲染完成后执行。这样的话，一旦 effect 的依赖发生变化，它就会被重新创建。 </p>
</blockquote>
<p> 给 effect 函数里面再返回一个函数，返回的函数会在组件销毁之前执行</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这个函数在组件销毁之前执行，componentWillUnmount'</span>)</span><br><span class="line">    clearInterval(timer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>给 useEffect 传递第二个参数，是一个数组，数组中写上需要监听的数据</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [name, setName] = useState(<span class="string">'张三'</span>) </span><br><span class="line"></span><br><span class="line"> useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'监听 name 数据的变化'</span>)</span><br><span class="line"> &#125;, [name])</span><br></pre></td></tr></table></figure>

<p>将 useEffect 第二个参数，设置为空数组只会默认执行一次就结束</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'默认执行一次'</span>)</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>

<h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><blockquote>
<p>接收一个 context 对象，实现供应商与消费者之间的关系</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyCtx = React.createContext()</span><br><span class="line"><span class="keyword">const</span> Provider = MyCtx.Provider</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App3 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [color, setColor] = useState(<span class="string">"blue"</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider value=&#123;color&#125;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;App3&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button</span></span><br><span class="line"><span class="regexp">          onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            setColor("#f40")&#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">            改变颜色&lt;/</span>button&gt;</span><br><span class="line">        &lt;One&gt;<span class="xml"><span class="tag">&lt;/<span class="name">One</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Provider&gt;</span><br><span class="line">  )&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> One = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> value = useContext(MyCtx) <span class="comment">// 接收供应商传递的数据信息</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2 style=&#123;&#123; <span class="attr">color</span>: value &#125;&#125;&gt;One&lt;<span class="regexp">/h2&gt; /</span><span class="regexp">/ 此时颜色应该为 blue</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>框架</tag>
        <tag>新增</tag>
      </tags>
  </entry>
  <entry>
    <title>this指向和render性能优化</title>
    <url>/2019/12/20/this%E6%8C%87%E5%90%91%E5%92%8Crender%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h2><blockquote>
<p>在ES6模块化代码中，全局this的默认指向是undefined  </p>
</blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123; this.handleClick &#125;&gt;点我&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">handleClick () &#123;</span></span><br><span class="line"><span class="regexp">    console.log(this) /</span><span class="regexp">/ 输出Undefined</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<blockquote>
<p>onClick 并不是onclick原生点击事件，它只是一个写在虚拟DOM中的一个属性</p>
</blockquote>
<blockquote>
<p>所以，为了解决这类的问题，提出了 4 种解决方案</p>
</blockquote>
<h3 id="一-，直接在表达式后面使用-bind-返回一个新的函数-改变-this的指向"><a href="#一-，直接在表达式后面使用-bind-返回一个新的函数-改变-this的指向" class="headerlink" title="一 ，直接在表达式后面使用 bind()返回一个新的函数 改变 this的指向"></a>一 ，直接在表达式后面使用 bind()返回一个新的函数 改变 this的指向</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123; <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>) &#125;&gt;点我&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="二，在构造函数中提前进行-bind-操作"><a href="#二，在构造函数中提前进行-bind-操作" class="headerlink" title="二，在构造函数中提前进行 bind 操作"></a>二，在构造函数中提前进行 bind 操作</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123; this.handleClick &#125;&gt;点我&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="三，使用箭头函数来作为事件处理函数，然后在箭头函数中调用最终的函数"><a href="#三，使用箭头函数来作为事件处理函数，然后在箭头函数中调用最终的函数" class="headerlink" title="三，使用箭头函数来作为事件处理函数，然后在箭头函数中调用最终的函数"></a>三，使用箭头函数来作为事件处理函数，然后在箭头函数中调用最终的函数</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123; () =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.handleClick()</span><br><span class="line">    &#125; &#125;&gt;点我&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="四，使用-public-class-filed-新语法。并将函数写成箭头函数的形式"><a href="#四，使用-public-class-filed-新语法。并将函数写成箭头函数的形式" class="headerlink" title="四，使用 public class filed 新语法。并将函数写成箭头函数的形式"></a>四，使用 public class filed 新语法。并将函数写成箭头函数的形式</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123; this.handleClick &#125;&gt;点我&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">handleClick = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  console.log(this)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="render性能优化问题"><a href="#render性能优化问题" class="headerlink" title="render性能优化问题"></a>render性能优化问题</h2><blockquote>
<p>父组件一旦render 子组件一定会render</p>
</blockquote>
<blockquote>
<p>为了节省性能,父组件render的时候,子组件没有更新必要的时候,就应该让子组件不render</p>
</blockquote>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>让子组件继承 PureComponent 基础组件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用这种性能优化后,推荐使用下面两种 this 指向问题的解决方案</p>
<ol>
<li>在构造函数进行this指向的处理</li>
<li>public class filed 新语法的方式</li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>笔记</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>React生命周期</title>
    <url>/2019/12/19/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="生命周期的三个阶段"><a href="#生命周期的三个阶段" class="headerlink" title="生命周期的三个阶段"></a>生命周期的三个阶段</h2><h3 id="1-挂载阶段"><a href="#1-挂载阶段" class="headerlink" title="1. 挂载阶段"></a>1. 挂载阶段</h3><h4 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor 构造函数"></a>constructor 构造函数</h4><pre><code>1. 一次生命周期中，只会触发一次
2. 一般是用来 state 的初始化
3. 使用它来做提前的 事件处理函数 this 绑定问题</code></pre><h4 id="render-函数"><a href="#render-函数" class="headerlink" title="render 函数"></a>render 函数</h4><pre><code>1. 一次生命周期中，可以触发多次
2. 主要是用来返回 组件的模板内容
3. 只要 state，prop 发生变化，那么这个函数默认情况下一定会重新执行
4. 如果调用了 forceUpdate() 那么 render一定会重新执行
5. 不能在这发生Ajax|Axios请求</code></pre><a id="more"></a><h4 id="componentWillMount-挂载之前（过期）"><a href="#componentWillMount-挂载之前（过期）" class="headerlink" title="componentWillMount 挂载之前（过期）"></a>componentWillMount 挂载之前（过期）</h4><h4 id="static-getDerivedStateFromProps-props-state-替代挂载之前-派生state数据"><a href="#static-getDerivedStateFromProps-props-state-替代挂载之前-派生state数据" class="headerlink" title="static getDerivedStateFromProps(props, state)替代挂载之前   派生state数据"></a>static getDerivedStateFromProps(props, state)替代挂载之前   派生state数据</h4><pre><code>1. 触发在 render函数之前，挂载与更新阶段都会触发
2. 必须返回对象或者null。返回的如果是对象的话，会和state对象合并一份新的state。如果是null的话就不做处理</code></pre><h4 id="componentDidMount-挂载完成"><a href="#componentDidMount-挂载完成" class="headerlink" title="componentDidMount 挂载完成"></a>componentDidMount 挂载完成</h4><pre><code>1. 可以进行Ajax数据请求
2. 可以得到真实的DOM对象</code></pre><h3 id="2-更新阶段（五个步骤）"><a href="#2-更新阶段（五个步骤）" class="headerlink" title="2. 更新阶段（五个步骤）"></a>2. 更新阶段（五个步骤）</h3><h4 id="01-—-static-getDerivedStateFromProps-props-state-派生state数据"><a href="#01-—-static-getDerivedStateFromProps-props-state-派生state数据" class="headerlink" title="01 — static getDerivedStateFromProps(props, state) 派生state数据"></a>01 — static getDerivedStateFromProps(props, state) 派生state数据</h4><h4 id="02-—-shouldComponentUpdate-nextProps-nextState-判断是否应该更新"><a href="#02-—-shouldComponentUpdate-nextProps-nextState-判断是否应该更新" class="headerlink" title="02 — shouldComponentUpdate(nextProps, nextState)  判断是否应该更新"></a>02 — shouldComponentUpdate(nextProps, nextState)  判断是否应该更新</h4><pre><code>1. 比较重要，是实现性能优化的一个点
2. 必须提供返回值，返回一个布尔类型的值，为true，继续流程，为 false，流程结束</code></pre><h4 id="03-—-render函数"><a href="#03-—-render函数" class="headerlink" title="03 —  render函数"></a>03 —  render函数</h4><h4 id="componentWillUpdate-更新之前（过期）"><a href="#componentWillUpdate-更新之前（过期）" class="headerlink" title="componentWillUpdate() 更新之前（过期）"></a>componentWillUpdate() 更新之前（过期）</h4><h4 id="04-—-getSnapshotBeforeUpdate-prevProps-prevState-替代更新之前"><a href="#04-—-getSnapshotBeforeUpdate-prevProps-prevState-替代更新之前" class="headerlink" title="04 — getSnapshotBeforeUpdate(prevProps, prevState) 替代更新之前"></a>04 — getSnapshotBeforeUpdate(prevProps, prevState) 替代更新之前</h4><pre><code>1. 更新之前
2. 必须有返回值或者null 返回值的内容会给到componentDidUpdate 的第三个参数</code></pre><h4 id="05-—-componentDidUpdate-prevProps-prevState-snapshot-更新完成"><a href="#05-—-componentDidUpdate-prevProps-prevState-snapshot-更新完成" class="headerlink" title="05 — componentDidUpdate(prevProps, prevState, snapshot) 更新完成"></a>05 — componentDidUpdate(prevProps, prevState, snapshot) 更新完成</h4><pre><code>更新完成，并且真实DOM也更新完成</code></pre><h3 id="3-销毁阶段"><a href="#3-销毁阶段" class="headerlink" title="3. 销毁阶段"></a>3. 销毁阶段</h3><h4 id="componentWillUnmount-销毁之前"><a href="#componentWillUnmount-销毁之前" class="headerlink" title="componentWillUnmount 销毁之前"></a>componentWillUnmount 销毁之前</h4><pre><code>1. 做一些清理工作</code></pre><p><img src="https://i.loli.net/2019/12/19/wUjPnxB8DZfWcSY.png" alt="TIM截图20191219174707.png"><br>   <a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">原图链接</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>框架</tag>
        <tag>常用</tag>
      </tags>
  </entry>
  <entry>
    <title>React脚手架和JSX语法</title>
    <url>/2019/12/18/React%E8%84%9A%E6%89%8B%E6%9E%B6%E5%92%8CJSX%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="React搭建"><a href="#React搭建" class="headerlink" title="React搭建"></a>React搭建</h2><blockquote>
<p>脚手架的使用</p>
</blockquote><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><blockquote>
<p>npx create-react-app 项目名字   ||    yarn create react-app 项目的名字</p>
</blockquote><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><blockquote>
<p>npm start  ||  yarn start   </p>
</blockquote><a id="more"></a>


<h3 id="打包上线"><a href="#打包上线" class="headerlink" title="打包上线"></a>打包上线</h3><blockquote>
<p>npm run build || yarn build</p>
</blockquote>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><blockquote>
<p>npm run test || yarn test</p>
</blockquote>
<h3 id="封印解除"><a href="#封印解除" class="headerlink" title="封印解除"></a>封印解除</h3><blockquote>
<p>npm run eject || yarn eject  可以修改webpack配置</p>
</blockquote>
<h2 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h2><blockquote>
<p> SX 将 HTML 语法直接加入到 JavaScript 代码中，再通过翻译器转换成 <strong>纯JavaScript</strong> 。在实际开发中，JSX 在产品打包阶段都已经编译成 纯JavaScript 了，不会带来副作用，反而让代码更加直观并易于维护。</p>
</blockquote>
<blockquote>
<p> JSX 的官方定义是 <strong>类XML语法的ECMAScript扩展</strong>。它完美地利用了 JavaScript 自带的语法和特性。并使用大家熟悉的HTML语法来创建虚拟元素。  </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 react</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Fragment &#125; <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="comment">// 引入 ReactDom</span></span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">"react-dom"</span></span><br><span class="line"><span class="comment">// 需要使用 ReactDom.render() 渲染挂载点</span></span><br><span class="line"><span class="keyword">const</span> msg = <span class="string">"msg的使用"</span></span><br><span class="line">ReactDom.render(</span><br><span class="line">  &lt;Fragment&gt;</span><br><span class="line">    &lt;h1 className=<span class="string">"abc"</span> style=&#123;&#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;&#125;&gt;</span><br><span class="line">      &#123;msg&#125;</span><br><span class="line">    &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p title=&#123;msg&#125;&gt;&#123;msg&#125;&lt;/</span>p&gt;</span><br><span class="line">  &lt;<span class="regexp">/Fragment&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById("root")</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h2 id="jsx的特征"><a href="#jsx的特征" class="headerlink" title="jsx的特征"></a>jsx的特征</h2><p> 单个根元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Fragment&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p> 单标签必须闭合，比如 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;br /&gt; <span class="xml"><span class="tag">&lt;<span class="name">img</span> /&gt;</span> <span class="tag">&lt;<span class="name">input</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>

<p> img标签必须要含有 alt 属性<br> 普通标签都是小写字母，组件标签首字母需要大写<br> class 需要写成 className </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p className=<span class="string">"abc"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p> for 需要 写成 htmlFor</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;label htmlFor=<span class="string">"id"</span>&gt;hello&lt;<span class="regexp">/label&gt;</span></span><br></pre></td></tr></table></figure>

<p> style属性要写成对象的形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p style=&#123;&#123;<span class="attr">color</span>: <span class="string">'red'</span>&#125;&#125;&gt; hello &lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>jsx就是个语法糖，其实就是 React.createElement()方法的调用</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Fragment&gt;</span><br><span class="line">    &lt;div&gt;<span class="number">123</span>&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Fragment&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>笔记</tag>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title>React虚拟DOM和组件</title>
    <url>/2019/12/18/React%E8%99%9A%E6%8B%9FDOM%E5%92%8C%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><blockquote>
<p>React 的 高效主要是体现在DOM上，在渲染新的元素的时候生成新的虚拟DOM元素和上次的虚拟DOM进行比较（diff算法）得出最小的修改点，然后用最小的代价进行DOM修改</p>
</blockquote><p><img src="https://www.reactjscn.com/granular-dom-updates-c158617ed7cc0eac8f58330e49e48224.gif" alt="示例"></p><h2 id="函数组件（无状态组件）"><a href="#函数组件（无状态组件）" class="headerlink" title="函数组件（无状态组件）"></a>函数组件（无状态组件）</h2><blockquote>
<p>有无状态是指有无 state 数据（这个 state 数据，可以看成是 vue 中的 data）</p>
</blockquote><a id="more"></a>


<blockquote>
<p>函数组件的 props 数据发生变化，会引起 函数组件的重新调用</p>
</blockquote>
<ol>
<li>函数名就是组件的名字首字母需要大写</li>
<li>函数体需要返回一段 JSX 代码 这段代码就是组件的模板的内容</li>
<li>函数接收一个 props 的参数，是一个对象，存放的是调用这个组件时在组件标签上定义的属性</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="comment">// 定义组件</span></span><br><span class="line"><span class="keyword">const</span> Hello = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt; div &gt;</span><br><span class="line">      &lt;h1&gt; hello 我是一个组件&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;World&gt;&lt;/</span>World&gt;</span><br><span class="line">    &lt;<span class="regexp">/div &gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const World = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h1&gt;我是一个子组件&lt;/</span>h1&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 利用组件进行页面渲染</span></span><br><span class="line"><span class="regexp">ReactDom.render(</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Hello&gt;&lt;/</span>Hello&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<h2 id="类组件（有状态组件）"><a href="#类组件（有状态组件）" class="headerlink" title="类组件（有状态组件）"></a>类组件（有状态组件）</h2><blockquote>
<p>类组件的 state 或者 props 数据发生变化，会引起 类组件的 render 方法重新调用，也就是更新页面</p>
</blockquote>
<ol>
<li>类的名字就是组件的名字，首字母需要大写</li>
<li>类组件必须继承 React.Component 这个基础组件</li>
<li>类组件必须要提供一个 render 函数，render 函数的返回值就是组件的模板内容</li>
<li>类实例的 props 属性，就是 props 数据</li>
<li>在构造函数中，初始化 state</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span> <span class="comment">// 引入组件</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 接收传递的信息</span></span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="comment">// 提供了构造函数，就必须要在最前面调用super()</span></span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="comment">// 初始化 state</span></span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            msg: <span class="string">'我是state'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    onClick () &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            msg; <span class="string">'我已经被 button 修改了'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;hello 我是&#123;name&#125;&lt;<span class="regexp">/h1&gt;    &#123;/</span>**接收调用者的传值并发送给props *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">    		&lt;p&gt;&#123;msg&#125;&lt;/</span>p&gt;</span><br><span class="line">			&#123;<span class="comment">/**通过 bind 返回一个新的函数改变 this的指向 */</span>&#125;</span><br><span class="line">		&lt;button onClick=&#123;<span class="keyword">this</span>.onClick.bind(<span class="keyword">this</span>)&#125;&gt;点击修改msg&lt;<span class="regexp">/button&gt;		</span></span><br><span class="line"><span class="regexp">	)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 组件的调用并传值</span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Hello name="类组件"&gt;&lt;/</span>Hello&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意几点：</p>
<ol>
<li>使用 constructor接收 props 一定要在函数第一行调用 super()</li>
<li>onClick 点击事件一定要用驼峰写法</li>
<li>必须要用 bind() 改变this 的指向，否则 this 是 undefined</li>
<li>改变 state 值时，不可以使用 this.state ，需要使用 this.setState才能修改</li>
</ol>
</blockquote>
<p><img src="https://i.loli.net/2019/12/18/G3c2SU84FkyuC1D.png" alt="示例"></p>
<h2 id="React-组件-与-Vue-组件的不同之处"><a href="#React-组件-与-Vue-组件的不同之处" class="headerlink" title="React 组件 与 Vue 组件的不同之处"></a>React 组件 与 Vue 组件的不同之处</h2><ol>
<li>Vue 有全局组件的概念，而 React 没有，任何文件需要使用哪个组件，就需要在这个文件中引入这个组件。</li>
<li>Vue 组件需要注册，Vue.component() 全局注册，或者 components 来局部注册 而 React 组件不需要注册</li>
<li>Vue 组件不需要考虑大小写。而 React 组件的首字母一定要大写</li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>笔记</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>Yarn操作命令</title>
    <url>/2019/12/18/Yarn%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h1><blockquote>
<p>一款包资源管理器</p>
</blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<p>npm install yarn -g</p>
</blockquote><h2 id="与npm的对比"><a href="#与npm的对比" class="headerlink" title="与npm的对比"></a>与npm的对比</h2><table>
<thead>
<tr>
<th>描述</th>
<th>npm</th>
<th>yarn</th>
</tr>
</thead>
<tbody><tr>
<td>项目初始化</td>
<td>npm init -y</td>
<td>yarn init -y</td>
</tr>
<tr>
<td>安装资源 - 开发环境</td>
<td>npm install –save-dev xxx</td>
<td>yarn add xxx -D</td>
</tr>
<tr>
<td>安装资源</td>
<td>npm install –save xxxx</td>
<td>yarn add xxx</td>
</tr>
<tr>
<td>根据package.json主动安装</td>
<td>npm install</td>
<td>yarn</td>
</tr>
<tr>
<td>全局安装</td>
<td>npm install -g xxx</td>
<td>yarn global add xxx</td>
</tr>
<tr>
<td>删除模块</td>
<td>npm uninstall –save-dev xxx <br>npm uninstall –save xxx<br>npm uninstall -g xxx</td>
<td>yarn remove xxx<br>yarn remove xxx -D<br>yarn global remove xxx</td>
</tr>
<tr>
<td>运行脚本</td>
<td>npm start<br>npm run 脚本名</td>
<td>yarn start<br>yarn run 脚本名| yarn 脚本名</td>
</tr>
<tr>
<td>获取当前源</td>
<td>npm config get registry</td>
<td>yarn config get registry</td>
</tr>
<tr>
<td>换源</td>
<td>npm config set registry xxx</td>
<td>yarn config set registry xxx</td>
</tr>
<tr>
<td>资源锁文件</td>
<td>package-lock.json</td>
<td>yarn.lock</td>
</tr>
</tbody></table>]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>yarn</tag>
      </tags>
  </entry>
  <entry>
    <title>项目部署上线</title>
    <url>/2019/12/17/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<blockquote>
<p>项目上线就是将项目放在线上服务器进行运行</p>
</blockquote><blockquote>
<p>相信大家学完框架做了一些实战项目后，想要展示给大家是要将项目上线的</p>
</blockquote><h2 id="服务器购买"><a href="#服务器购买" class="headerlink" title="服务器购买"></a>服务器购买</h2><ul>
<li>服务器我是在腾讯云购买的    </li>
<li>尽量选择 <strong>CentOS7.x</strong>版本购买</li>
</ul><p><a href="https://cloud.tencent.com/" target="_blank" rel="noopener">进入官网</a></p><h2 id="nginx安装"><a href="#nginx安装" class="headerlink" title="nginx安装"></a>nginx安装</h2><p> <img src="https://i.loli.net/2019/12/17/2AOJlhzIdfi1k5r.png" alt="示例"></p><a id="more"></a>




<blockquote>
<p>首先点击登录进入Linux服务端开始操作命令 </p>
</blockquote>
<h3 id="安装-nginx-可以照着官网的步骤安装即可"><a href="#安装-nginx-可以照着官网的步骤安装即可" class="headerlink" title="安装 nginx 可以照着官网的步骤安装即可"></a>安装 nginx 可以照着官网的步骤安装即可</h3><p><a href="http://nginx.org/en/linux_packages.html#RHEL-CentOS" target="_blank" rel="noopener">文档链接</a></p>
<h3 id="检验安装是否成功"><a href="#检验安装是否成功" class="headerlink" title="检验安装是否成功"></a>检验安装是否成功</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nginx</span> -v</span><br></pre></td></tr></table></figure>

<h3 id="启动-nginx"><a href="#启动-nginx" class="headerlink" title="启动 nginx"></a>启动 nginx</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure>

<h3 id="在浏览器输入服务器的公网-IP-地址-正常输出为下面页面"><a href="#在浏览器输入服务器的公网-IP-地址-正常输出为下面页面" class="headerlink" title="在浏览器输入服务器的公网 IP 地址 正常输出为下面页面"></a>在浏览器输入服务器的公网 IP 地址 正常输出为下面页面</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/382590/1562170125986-f6b342a9-e1ff-4824-8766-7461a91e0229.png" alt></p>
<h3 id="nginx-的默认-web-根目录"><a href="#nginx-的默认-web-根目录" class="headerlink" title="nginx 的默认 web 根目录"></a>nginx 的默认 web 根目录</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">/usr/share/nginx/html</span><br></pre></td></tr></table></figure>

<h2 id="项目上线"><a href="#项目上线" class="headerlink" title="项目上线"></a>项目上线</h2><h3 id="安装FTP客户端"><a href="#安装FTP客户端" class="headerlink" title="安装FTP客户端"></a>安装FTP客户端</h3><p><a href="https://www.filezilla.cn/" target="_blank" rel="noopener">下载链接</a></p>
<p><img src="https://i.loli.net/2019/12/17/JPXul5fvqgFpcnQ.png" alt="示例"></p>
<blockquote>
<p> 输入自己的 IP 地址 以及密码即可，端口号一般都是22</p>
</blockquote>
<h4 id="上传Vue项目至服务器并运行"><a href="#上传Vue项目至服务器并运行" class="headerlink" title="上传Vue项目至服务器并运行"></a>上传Vue项目至服务器并运行</h4><ol>
<li>npm run build 生成一个dist文件夹</li>
<li>将dist里面的文件全部上传至服务器 nginx web根目录下</li>
</ol>
<blockquote>
<p>PS：并不是将dist整个文件夹上传，而是选中dist文件夹下面的所有文件进行上传</p>
</blockquote>
<h2 id="安装-node"><a href="#安装-node" class="headerlink" title="安装 node"></a>安装 node</h2><blockquote>
<p>node 是很多项目所必备的一样东西，在服务器上面也是必不可少的</p>
</blockquote>
<ol>
<li>选择目录： <code>cd/usr/local</code></li>
<li>下载Node包：<code>wget http://npm.taobao.org/mirrors/node/v12.13.1/node-v12.13.1-linux-x64.tar.xz</code></li>
<li>解压xz：<code>xz -d node-v12.13.1-linux-x64.tar.xz</code></li>
<li>解压tar：<code>tar -xvf node-v12.13.1-linux-x64.tar</code></li>
<li>删除无用的tar文件：<code>rm -rf node-v12.13.1-linux-x64.tar</code></li>
<li>修改文件名字：<code>mv node-v12.13.1-linux-x64 node</code></li>
<li>配置环境变量，是node npm npx 命令可以在服务器全局使用<ol>
<li>编辑文件 <code>vim/etc/profile</code>，在文件的最后一行添加内容 <code>export PATH=$PATH:/usr/local/node/bin</code></li>
<li>使配置生效：<code>source/etc/profile</code></li>
<li>最后在任意目录下检验 <code>node -v</code>是否全局使用</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>项目相关</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>服务器</tag>
        <tag>项目流程</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack</title>
    <url>/2019/12/17/Webpack/</url>
    <content><![CDATA[<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><blockquote>
<p>现代化前端最流行的一款 构建打包工具</p>
</blockquote><h3 id="webpack-打包构建原理"><a href="#webpack-打包构建原理" class="headerlink" title="webpack 打包构建原理"></a>webpack 打包构建原理</h3><blockquote>
<p>基于某个入口文件，分析这个文件中的依赖，接着继续向下寻找依赖所属的依赖</p>
<p>循环往复，直到没有依赖为止，最后进行打包处理</p>
</blockquote><h3 id="webpack-核心"><a href="#webpack-核心" class="headerlink" title="webpack 核心"></a>webpack 核心</h3><a id="more"></a>

<ol>
<li>entry（入口）</li>
<li>output（出口）</li>
<li>loader（转换器）</li>
</ol>
<blockquote>
<p> webpack 将依赖都看成是一个一个的模块。但是默认情况只能识别 js与json 两种格式的模块。如果想要打包图片、样式等资源的话，就需要相应的loader转换器来进行转换操作，转换之后webpack才能识别。</p>
</blockquote>
<ol start="4">
<li>plugins（插件）</li>
</ol>
<blockquote>
<p>有一些操作转换器也实现不了，这时就可以交给插件来实现。比如说要将某个文件直接复制到出口文件里面等操作。</p>
</blockquote>
<ol start="5">
<li>mode（打包模式 4.x 版本之后提供）开发 | 生产</li>
</ol>
<h3 id="webpack简易搭建流程"><a href="#webpack简易搭建流程" class="headerlink" title="webpack简易搭建流程"></a>webpack简易搭建流程</h3><blockquote>
<p>新建文件  <code>mkdir webpack-demo</code></p>
</blockquote>
<blockquote>
<p>初始化  <code>npm init -y</code></p>
</blockquote>
<blockquote>
<p>安装开发依赖  <code>npm install -D webpack webpack-cli</code></p>
</blockquote>
<blockquote>
<p>三种运行方式:</p>
<ul>
<li><code>./node_modules/.bin/webpack</code></li>
<li><code>npx webpack</code></li>
<li><code>npm run build</code>（ 在 package.json 文件中修改运行命令即可 ）</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line"> "build": "webpack"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</blockquote>
<p>更多详细操作流程可以查看 <a href="https://www.webpackjs.com/guides/installation/" target="_blank" rel="noopener">官 网</a></p>
<h4 id="入口-amp-出口"><a href="#入口-amp-出口" class="headerlink" title="入口 &amp; 出口"></a>入口 &amp; 出口</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口</span></span><br><span class="line">  entry: <span class="string">"./src/index.js"</span>,</span><br><span class="line">  <span class="comment">// 出口</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"main.js"</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><h4 id="自动生成-dist-index-html"><a href="#自动生成-dist-index-html" class="headerlink" title="自动生成 dist /  index.html"></a>自动生成 dist /  index.html</h4><ol>
<li>安装插件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置插件 — webpack.config.js</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>) <span class="comment">// 引入</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    <span class="comment">// 可以传递一个template选项，来控制使用哪个模板页面来生成</span></span><br><span class="line">    template: path.resolve(__dirname, <span class="string">'./public/index.html'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="将public文件夹内容全部拷贝至-dist-出口文件夹"><a href="#将public文件夹内容全部拷贝至-dist-出口文件夹" class="headerlink" title="将public文件夹内容全部拷贝至 dist 出口文件夹"></a>将public文件夹内容全部拷贝至 dist 出口文件夹</h4><ol>
<li>安装插件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev copy-webpack-plugin</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置插件 —  webpack.config.js</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">"copy-webpack-plugin"</span>) <span class="comment">// 引入</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> CopyWebpackPlugin([</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">from</span>: path.resolve(__dirname, <span class="string">'./public'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ])</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="常用转换器"><a href="#常用转换器" class="headerlink" title="常用转换器"></a>常用转换器</h3><h4 id="引入css样式"><a href="#引入css样式" class="headerlink" title="引入css样式"></a>引入css样式</h4><blockquote>
<p>需要两个转换器：style-loader | css-loader</p>
</blockquote>
<blockquote>
<p>css-loader: 将css文件转换成 webpack 能够识别的模块文件</p>
</blockquote>
<blockquote>
<p>style-loader: 将css写入到html页面的style标签中</p>
</blockquote>
<ol>
<li>安装转换器</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -D style-loader css-loader</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置转换器规则  —  webpack.config.js</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">   <span class="comment">// 填写转换器的配置，规则</span></span><br><span class="line">   rules: [</span><br><span class="line">     &#123;</span><br><span class="line">       test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">       <span class="comment">// 多个转换器使用时，需要按照倒序的写法</span></span><br><span class="line">       use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">     &#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<h4 id="引入scss样式"><a href="#引入scss样式" class="headerlink" title="引入scss样式"></a>引入scss样式</h4><blockquote>
<p>除了上面两个转换器，还需要额外安装两个转换器</p>
</blockquote>
<ol>
<li>安装转换器</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -D sass-loader node-sass</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置路由器规则   —   webpack.config.js</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(scss|sass)$/</span>,</span><br><span class="line">  use: [<span class="string">"style-loader"</span>, <span class="string">"css-loader"</span>, <span class="string">"sass-loader"</span>]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>引入图片</strong></p>
<blockquote>
<p>图片也需要使用模块的方式将其引入</p>
</blockquote>
<ol>
<li>安装转换器</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -D url-loader</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置并引入   —   src/ index.js</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Icon <span class="keyword">from</span> <span class="string">'./assets/1.jpg'</span> <span class="comment">// 引入图片</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">component</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>)</span><br><span class="line">  <span class="keyword">var</span> myIcon = <span class="keyword">new</span> Image()</span><br><span class="line">  myIcon.src = Icon</span><br><span class="line">  element.appendChild(myIcon)</span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(component())</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -- webpack.config.js</span></span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">    use: [<span class="string">"file-loader"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>项目相关</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>构建工具</tag>
        <tag>项目必备</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue生命周期</title>
    <url>/2019/12/03/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h2><blockquote>
<p>一个vue的实例在它创建到销毁的一系列过程，就叫做生命周期</p>
</blockquote><h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><blockquote>
<p>在vue实例的生命周期中，某个特定的时刻会自动触发的函数，就叫做生命周期的钩子函数</p>
</blockquote><p><strong>注意</strong>：</p><blockquote>
<p>Ajax请求并不是要在特定的钩子函数才能请求，因为异步原因，在任意挂载阶段请求都可以</p>
<p>Ajax最后都会在挂载阶段完成后请求成功   放在created钩子函数中可以更加的便于逻辑理解 </p>
<p>更新阶段在页面数据进行变化，钩子函数才会执行</p>
</blockquote><a id="more"></a>



<h2 id="分为三个阶段"><a href="#分为三个阶段" class="headerlink" title="分为三个阶段"></a>分为三个阶段</h2><h4 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h4><ol>
<li>beforeCreate</li>
<li>created</li>
<li>beforeMount</li>
<li>mounted</li>
</ol>
<h4 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h4><ol start="5">
<li>beforeUpdate</li>
<li>updated</li>
</ol>
<h4 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h4><ol start="7">
<li>beforeDestroy</li>
<li>destroyed</li>
</ol>
<hr>
<ol>
<li><p><strong>beforeCreate</strong>———实例创建之前                                                        </p>
<ul>
<li><p>拿不到数据与方法</p>
</li>
<li><p>拿不到真实的dom对象：this.$el</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt; &lt;div&gt;   &lt;h1 id=&quot;box&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;   &lt;/div&gt;   &lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;msg: &quot;Hello&quot;&#125;;</span><br><span class="line">    &#125;,   </span><br><span class="line">	beforeCreate() &#123;</span><br><span class="line">      	console.log(&quot;实例创建之前------------&quot;);</span><br><span class="line">      	console.log(this.msg); //数据 undefined</span><br><span class="line">      	console.log(this.$el); //DOM对象 undefined</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>created</strong>————–实例创建完成</p>
<ul>
<li><p>拿不到真实的dom对象：this.$el</p>
</li>
<li><p>可以拿到数据和方法（Ajax请求）</p>
</li>
<li><p>调用方法，发送异步请求等等</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"实例创建完成------------"</span>);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg); <span class="comment">// hello   可以获取数据和方法（发送ajax请求效率最高）</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el); <span class="comment">// undefined</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>beforeMount</strong>———-实例挂载之前</p>
<ul>
<li>拿不到真实的dom对象：this.$el</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeMount() &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"实例挂载之前------------"</span>);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg); <span class="comment">// hello</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el); <span class="comment">//undefined</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mounted</strong>————-实例挂载完成</p>
<ul>
<li><p>可以拿到真实的dom对象：this.$el  </p>
</li>
<li><p>调用方法，发送异步请求等等</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"实例挂载完成------------"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el); <span class="comment">//&lt;div&gt;...&lt;/div&gt; 可以获取dom对象</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>beforeUpdate</strong>———–实例更新之前</p>
<ul>
<li>获取当前数据的时候是旧数据</li>
</ul>
</li>
<li><p><strong>updated</strong>——————实例更新完成</p>
<ul>
<li>数据更新完成，真实dom也更新完成</li>
</ul>
</li>
<li><p><strong>beforeDestroy</strong>————-实例销毁之前</p>
<ul>
<li>清除定时器</li>
<li>清除全局绑定的滚动条事件</li>
</ul>
</li>
<li><p><strong>destroyed</strong>—————实例销毁完成</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>笔记</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>mongoDB</title>
    <url>/2019/11/20/mongoDB/</url>
    <content><![CDATA[<h2 id="mongoDB"><a href="#mongoDB" class="headerlink" title="mongoDB"></a>mongoDB</h2><blockquote>
<p> MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 </p>
</blockquote><h2 id="MongoDB-集合"><a href="#MongoDB-集合" class="headerlink" title="MongoDB - 集合"></a>MongoDB - 集合</h2><ul>
<li>集合就是MongoDB的文档集合。类型于关系型数据库中的<strong>表格</strong>。 </li>
<li>集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。 </li>
</ul><a id="more"></a>

<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"genres"</span>: [<span class="string">"犯罪"</span>, <span class="string">"剧情"</span>], <span class="string">"title"</span>: <span class="string">"肖申克的救赎"</span>&#125;</span><br><span class="line">&#123;<span class="string">"genres"</span>: [<span class="string">"搞笑"</span>, <span class="string">"无聊"</span>], <span class="string">"title"</span>: <span class="string">"李茶的姑妈"</span>&#125;</span><br><span class="line">&#123;<span class="string">"genres"</span>: [<span class="string">"好看"</span>], <span class="string">"title"</span>: <span class="string">"无双"</span>, <span class="string">"stars"</span>: <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MongoDB-数据库常用命令"><a href="#MongoDB-数据库常用命令" class="headerlink" title="MongoDB - 数据库常用命令"></a>MongoDB - 数据库常用命令</h2><ul>
<li>创建/切换数据库</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">use [数据库名]</span><br></pre></td></tr></table></figure>

<ul>
<li>显示所有数据库</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">show dbs</span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前所在数据库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db</span><br></pre></td></tr></table></figure>

<ul>
<li>显示当前DB状态</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.stats()</span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前DB版本</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">db.version</span><br></pre></td></tr></table></figure>

<ul>
<li>删除当前数据库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.dropDatabase</span><br></pre></td></tr></table></figure>

<h2 id="MongoDB-集合常用命令-添加"><a href="#MongoDB-集合常用命令-添加" class="headerlink" title="MongoDB - 集合常用命令 - 添加"></a>MongoDB - 集合常用命令 - 添加</h2><ul>
<li>save </li>
<li>insertOne </li>
<li>insertMany </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.users.save(&#123;name: '张三', age: 16&#125;);</span><br><span class="line"></span><br><span class="line">db.users.insertOne(&#123;name: '张三', age: 18&#125;);</span><br><span class="line"></span><br><span class="line">db.users.insertMany([&#123;name: '李四', age: 19&#125;, &#123;name: '王五', age: 20&#125;]);</span><br></pre></td></tr></table></figure>

<h2 id="MongoDB-集合常用命令-修改"><a href="#MongoDB-集合常用命令-修改" class="headerlink" title="MongoDB - 集合常用命令 - 修改"></a>MongoDB - 集合常用命令 - 修改</h2><ul>
<li><p>save 传入 _id 时，可作为更新操作。 </p>
</li>
<li><p>update </p>
</li>
<li><p>updateOne </p>
</li>
<li><p>updateMany </p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.users.update(&#123;age: 25&#125;, &#123;$set: &#123;name: 'changeName'&#125;&#125;);</span><br><span class="line">// update users set name = 'changeName' where age = 25;</span><br><span class="line">db.users.update(&#123;name: 'lisi'&#125;, &#123;$inc: &#123;age: 50&#125;&#125;);</span><br><span class="line">// update users set age = age + 50  where name = 'lisi';</span><br><span class="line">db.users.update(&#123;name: 'lisi'&#125;, &#123;$inc: &#123;age: 50&#125;, $set: &#123;name: 'hoho'&#125;&#125;);</span><br><span class="line">// update users set age = age + 50, name = 'hoho' where name = 'lisi';</span><br></pre></td></tr></table></figure>

<h2 id="MongoDB-集合常用命令-删除"><a href="#MongoDB-集合常用命令-删除" class="headerlink" title="MongoDB - 集合常用命令 - 删除"></a>MongoDB - 集合常用命令 - 删除</h2><ul>
<li>remove </li>
<li>deleteOne </li>
<li>deleteMany </li>
</ul>
<h2 id="MongoDB-集合常用命令-查询"><a href="#MongoDB-集合常用命令-查询" class="headerlink" title="MongoDB - 集合常用命令 - 查询"></a>MongoDB - 集合常用命令 - 查询</h2><ul>
<li>查询所有记录</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.users.find()</span><br><span class="line"><span class="comment">// select * from users</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查询筛选</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.users.find(&#123;<span class="string">'age'</span>: <span class="number">22</span>&#125;);					查询 age = <span class="number">22</span> 的记录 </span><br><span class="line"></span><br><span class="line">db.users.find(&#123;<span class="string">'age'</span>: &#123;<span class="attr">$gt</span>: <span class="number">22</span>&#125;&#125;);			查询 age &gt; <span class="number">22</span> 的记录 </span><br><span class="line"></span><br><span class="line">db.users.find(&#123;<span class="string">'age'</span>: &#123;<span class="attr">$lt</span>: <span class="number">22</span>&#125;&#125;);			查询 age &lt; <span class="number">22</span> 的记录 </span><br><span class="line"></span><br><span class="line">db.users.find(&#123;<span class="string">'age'</span>: &#123;<span class="attr">$gte</span>: <span class="number">22</span>&#125;&#125;);			查询 age &gt;= <span class="number">22</span> 的记录 </span><br><span class="line"></span><br><span class="line">db.users.find(&#123;<span class="string">'age'</span>: &#123;<span class="attr">$lte</span>: <span class="number">22</span>&#125;&#125;);			查询 age &lt;= <span class="number">22</span> 的记录 </span><br><span class="line"></span><br><span class="line">db.users.find(&#123;<span class="string">'age'</span>: &#123;<span class="attr">$ne</span>: <span class="number">22</span>&#125;&#125;);			查询 age != <span class="number">22</span> 的记录 </span><br><span class="line"></span><br><span class="line">db.users.find(&#123;<span class="string">'age'</span>: &#123;<span class="attr">$gte</span>: <span class="number">23</span>, <span class="attr">$lte</span>: <span class="number">26</span>&#125;&#125;);查询 age &gt;= <span class="number">23</span> 并且 age &lt;= <span class="number">26</span> </span><br><span class="line"></span><br><span class="line">db.users.find(&#123;<span class="attr">$or</span>: [&#123;<span class="attr">age</span>: &#123;<span class="attr">$gte</span>: <span class="number">23</span>&#125;&#125;, &#123;<span class="attr">name</span>: <span class="string">'张三'</span>&#125;]);查询 age &gt;= <span class="number">23</span> 或者 name == <span class="string">'张三'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查询 name 中包含 mongo 的数据 </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.users.find(&#123;'name': /mongo/&#125;);</span><br><span class="line">// select * from users where name like %mongo%;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询 name 中已 mongo 开头的数据 </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.users.find(&#123;'name': /^mongo/&#125;);</span><br><span class="line">// select * from users where name like 'mongo%';</span><br></pre></td></tr></table></figure>

<ul>
<li>查询 name 中已 mongo 结尾的数据 </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.users.find(&#123;'name': /mongo$/&#125;);</span><br><span class="line">// select * from users where name like 'mongo%';</span><br></pre></td></tr></table></figure>

<ul>
<li>查询 指定列 name 、age 的数据</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.users.find(&#123;&#125;, &#123;name: 1, age: 1&#125;);</span><br><span class="line">// select name, age from users;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询 指定列 name 、age 并且 age &gt; 25 </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.users.find(&#123;age: &#123;$gt: 25&#125;&#125;, &#123;name: 1, age: 1&#125;);</span><br><span class="line">// select name, age from users where age &gt; 25;</span><br></pre></td></tr></table></figure>

<ul>
<li>升序 </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.users.find().sort(&#123;age: 1&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>倒序 </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.users.find().sort(&#123;age: -1&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>查询 name = zhangsan , age = 20 的数据 </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.users.find(&#123;name: '张三', age: 20&#125;);</span><br><span class="line">// select * from users where name='zhangsan' and age='20';</span><br></pre></td></tr></table></figure>

<ul>
<li>查询 前5条数据 </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.users.find().limit(5);</span><br><span class="line">// select top 5 * from users;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询 10条以后的数据 </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.users.find().skip(10);</span><br></pre></td></tr></table></figure>

<ul>
<li>查询 在 5 - 10 之间的数据 </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.usres.find().skip(5).limit(5)</span><br></pre></td></tr></table></figure>

<ul>
<li>查询 第一条数据 </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.users.findOne();</span><br></pre></td></tr></table></figure>

<h2 id="nodejs-操作-mongodb"><a href="#nodejs-操作-mongodb" class="headerlink" title="nodejs 操作 mongodb"></a>nodejs 操作 mongodb</h2><ol>
<li>安装<strong>mongodb</strong>依赖 </li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save mongodb</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>引入</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">const Mongodb = require('mongodb')</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>构建 mongodb 的连接地址 </li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">const url = 'mongodb://127.0.0.1:27017';</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>连接</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mongodb.connect(url, function(err, client) &#123;</span><br><span class="line">    // 4.1 选择数据库</span><br><span class="line">    const db = client.db('数据库名称');</span><br><span class="line"></span><br><span class="line">    // 4.2 选择集合并操作</span><br><span class="line">    db.collection('集合名称').find();</span><br><span class="line">    ...</span><br><span class="line">db</span><br><span class="line">    // 4.3 记得关闭连接</span><br><span class="line">    client.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>查询</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">查询全部</span><br><span class="line">.find()</span><br><span class="line"></span><br><span class="line">查询特定的数据</span><br><span class="line">.find(whereObj)</span><br><span class="line"></span><br><span class="line">排序</span><br><span class="line">.find().soft(softObj)</span><br><span class="line"></span><br><span class="line">查询指定条数</span><br><span class="line">.find().limit(count)</span><br><span class="line"></span><br><span class="line">跳过的条数</span><br><span class="line">.find().skip(count)</span><br></pre></td></tr></table></figure>



<h2 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h2><blockquote>
<p> nodejs环境下对 mongodb 进行便捷操作的对象模型工具 </p>
</blockquote>
<p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install mongoose --save</span><br></pre></td></tr></table></figure>

<p>建立连接</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config/db.js   创建一个config文件夹下面的db.js文件</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="comment">// 定义连接的地址，mz 是数据库的名字</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">'mongodb://localhost:27017/mz'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用 connect 方法进行连接。</span></span><br><span class="line"><span class="comment"> * 1. 回调函数的方式</span></span><br><span class="line"><span class="comment"> * 2. promise 方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mongoose.connect(url, &#123; useNewUrlParser: true &#125;, function(err) &#123;</span></span><br><span class="line"><span class="comment">//   if (err) &#123;</span></span><br><span class="line"><span class="comment">//     console.log('连接失败！', err.message);</span></span><br><span class="line"><span class="comment">//   &#125; else &#123;</span></span><br><span class="line"><span class="comment">//     console.log('连接成功~');</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">mongoose</span><br><span class="line">  .connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'连接成功~'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'连接失败!'</span>, err.message);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后将 mongoose 暴露出去</span></span><br><span class="line"><span class="built_in">module</span>.exports = mongoose;</span><br></pre></td></tr></table></figure>

<h3 id="schema"><a href="#schema" class="headerlink" title="schema"></a>schema</h3><blockquote>
<p> schema 是一种描述 mongodb 中 collection(集合) 结构的一种东西。 </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// models/banner.js 创建一个models文件夹下面的banner.js</span></span><br><span class="line"><span class="comment">// 引入 db.js </span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">'../config/db.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 schema</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> db.Schema(&#123;</span><br><span class="line">  name: <span class="built_in">String</span>,   <span class="comment">// banner 名字</span></span><br><span class="line">  imgUrl: <span class="built_in">String</span>, <span class="comment">// banner 图片地址</span></span><br><span class="line">  startTime: &#123;    <span class="comment">// banner 显示的开始时间</span></span><br><span class="line">    type: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="keyword">default</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  endTime: &#123;      <span class="comment">// banner 显示的结束时间</span></span><br><span class="line">    type: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="keyword">default</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + <span class="number">1</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>; <span class="comment">// 当前时间加 1 天</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于 schema 创建 model, 并暴露出去。</span></span><br><span class="line"><span class="built_in">module</span>.exports = db.model(<span class="string">'Banner'</span>, schema);</span><br></pre></td></tr></table></figure>

<h3 id="model"><a href="#model" class="headerlink" title="model"></a>model</h3><blockquote>
<p> 基于 Schema 编译来的构造函数。model 的实例代表着可以从数据库保存和读取的 documents。从数据库创建和读取 document 的所有操作都是 通过 model 进行的。 </p>
</blockquote>
<p> 上面 <strong>models/banner.js</strong> 文件最后暴露出去的就是 model </p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架</title>
    <url>/2019/11/19/Express/</url>
    <content><![CDATA[<h2 id="nodejs-express框架"><a href="#nodejs-express框架" class="headerlink" title="nodejs express框架"></a>nodejs express框架</h2><blockquote>
<p> 基于 Node.js 平台，快速、开放、极简的 Web 开发框架 。 </p>
</blockquote><h3 id="快速搭建express框架环境"><a href="#快速搭建express框架环境" class="headerlink" title="快速搭建express框架环境"></a>快速搭建express框架环境</h3><ol>
<li>创建一个项目</li>
<li>初始化 生成package.json    <code>npm init -y</code></li>
<li>下载安装这个项目的依赖模块  <code>npm install --save express</code></li>
<li>创建一个js文件，开始写代码</li>
</ol><a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 引入 express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 生成 express 的实例</span></span><br><span class="line"><span class="keyword">const</span> server = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 处理路由等等 (路由的概念，就是不同的url地址需要有不同的响应)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// http://localhost:8080    -&gt; hello express</span></span><br><span class="line">server.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'hello express'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://localhost:8080/login  -&gt; 登录</span></span><br><span class="line">server.get(<span class="string">'/login'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'登录页面'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 监听端口</span></span><br><span class="line">server.listen(<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><ul>
<li><strong>req.query</strong>：获取URL的查询参数串 </li>
<li><strong>req.body</strong>: 获取请求主体（post数据，需要设置中间件函数 json与urlencode） </li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//让代码支持 req.body 需要下面两行代码</span></span><br><span class="line">server.use(express.json())</span><br><span class="line">server.use(express.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">true</span> &#125;))</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>req.cookies</strong>：获取Cookies (需要使用 cookie-parser 中间件) </li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> server = express()</span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>)<span class="comment">//引入第三方中间件</span></span><br><span class="line"><span class="comment">//让代码支持req.cookie属性 需要使用cookie-parser 中间件</span></span><br><span class="line"><span class="comment">//1. 安装 cookie-parser 中间件</span></span><br><span class="line"><span class="comment">// 当前文件 npm install --save cookie-parser</span></span><br><span class="line"><span class="comment">//2. 在当前文件引入</span></span><br><span class="line"><span class="comment">//3. 使用express 实例的 use方法使用它</span></span><br><span class="line">server.use(cookieParser())</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>req.params</strong>：获取路由的动态参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://localhost:8080/hello/张三</span></span><br><span class="line"><span class="comment">// http://localhost:8080/hello/李四</span></span><br><span class="line">server.get(<span class="string">'/hello/:name'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.params)</span><br><span class="line">    res.send(<span class="string">`欢迎 - <span class="subst">$&#123;req.params.name&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>req.path：获取请求路径</li>
<li>req.hostname / req.ip：获取主机名和IP地址  </li>
<li>req.protocol：获取协议类型 </li>
<li>req.get()：获取指定的HTTP请求头 </li>
</ul>
<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><ul>
<li>res.set()：设置HTTP头，传入object可以一次设置多个头 </li>
<li>res.status()：设置HTTP状态码 </li>
<li>res.send()：传送HTTP响应 </li>
<li>res.redirect()：设置响应的Location HTTP头，并且设置状态码302 </li>
<li>res.json()：传送JSON响应 </li>
<li>res.cookie(name，value [，option])：设置Cookie </li>
<li>res.clearCookie()：清除Cookie </li>
<li>res.download()：传送指定路径的文件 </li>
<li>res.sendFile(path [，options] [，fn])：传送指定路径的文件 -会自动根据文件extension设定Content-Type </li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//__dirname 获取当前文件路径</span></span><br><span class="line">server.get(<span class="string">'/hello.html'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.sendFile(path.resolve(__dirname,<span class="string">'./hello.html'</span>)) <span class="comment">//必须是绝对路径</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>



<ul>
<li>res.render(view [, locals] [, callback]) 渲染一个view </li>
</ul>
<h3 id="EJS模板引擎"><a href="#EJS模板引擎" class="headerlink" title="EJS模板引擎"></a>EJS模板引擎</h3><blockquote>
<p>模板引擎的作用，就是将静态html页面给弄活。访问一个url地址，浏览器渲染出来的是html的内容。但是不是直接输出一个静态的html页面。而是后端在输出之前会将一个静态的html页面模板与数据先拼接。然后再输出。</p>
</blockquote>
<ol>
<li><p>新建项目</p>
</li>
<li><p>项目初始化 npm init  -y</p>
</li>
<li><p>安装项目依赖</p>
<ol>
<li><p>express</p>
</li>
<li><p>ejs</p>
</li>
</ol>
</li>
</ol>
<p>npm install –save express ejs</p>
<ol start="4">
<li><p>开始写代码</p>
<ol>
<li><p>需要通过 express 的实例的 set(‘view engine’, ‘xxx’) 来设置当前项目使用哪种模板引擎</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要通过 express 的实例的 set(‘views’, ‘xxx’) 来设置当前项目中模板页面的存放路径</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.set(<span class="string">'views'</span>, path.resolve(__dirname, <span class="string">'./views'</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>后续需要渲染模板页面的地方，就可以使用 res.render() 来操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.get(<span class="string">'/hello/:name'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="comment">//res.render('模板页面文字'，'需要传递到这个页面的数据')</span></span><br><span class="line">    res.render(<span class="string">'welcome'</span>, &#123;</span><br><span class="line">        name: req.params.name,</span><br><span class="line">        isLogin: <span class="literal">false</span>,<span class="comment">//是否登录</span></span><br><span class="line">        frusts: [</span><br><span class="line">            &#123; <span class="attr">name</span>: <span class="string">'xiaozhang'</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">name</span>: <span class="string">'xiaowang'</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">name</span>: <span class="string">'xiaohong'</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h3 id="EJS模板引擎常用标签"><a href="#EJS模板引擎常用标签" class="headerlink" title="EJS模板引擎常用标签"></a>EJS模板引擎常用标签</h3><ol>
<li>&lt;% %&gt; 流程控制标签 </li>
<li><strong>&lt;%= %&gt;</strong> 输出标签 (会对 HTML 代码转义) </li>
<li><strong>&lt;%- %&gt;</strong> 输出标签 (不对 HTML 代码转义) </li>
<li>&lt;%# %&gt; 注释标签 </li>
</ol>
<p>创建一个.ejs文件使用以下语法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎，<span class="tag">&lt;<span class="name">%=</span> <span class="attr">name</span> %&gt;</span> <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">isLogin</span>) &#123; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>退出登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125; <span class="attr">else</span> &#123; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &lt;% for (var i = 0; i &lt; frusts.length; i++) &#123; %&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">frusts</span>[<span class="attr">i</span>]<span class="attr">.name</span> %&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- include() 引入公用模板 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%-</span> <span class="attr">include</span>('<span class="attr">.</span>/<span class="attr">common</span>/<span class="attr">footer.ejs</span>') %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>nodeJS</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>node</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6基本使用</title>
    <url>/2019/11/04/ES6/</url>
    <content><![CDATA[<h2 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h2><ul>
<li>let关键字，用来声明变量，它的用法类似于var。</li>
</ul><h3 id="let不允许重复声明变量"><a href="#let不允许重复声明变量" class="headerlink" title="let不允许重复声明变量"></a>let不允许重复声明变量</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//Error</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<h3 id="let声明变量仅在块级作用域内有效"><a href="#let声明变量仅在块级作用域内有效" class="headerlink" title="let声明变量仅在块级作用域内有效"></a>let声明变量仅在块级作用域内有效</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;;</span><br><span class="line">alert(i); <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v = <span class="number">0</span>; v &lt; <span class="number">10</span>; v++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line">alert(v); <span class="comment">//Error</span></span><br></pre></td></tr></table></figure>

<h3 id="不能通过let声明和形参相同的变量"><a href="#不能通过let声明和形参相同的变量" class="headerlink" title="不能通过let声明和形参相同的变量"></a>不能通过let声明和形参相同的变量</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//Error</span></span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">456</span>);</span><br></pre></td></tr></table></figure>

<h3 id="let声明变量不会提升"><a href="#let声明变量不会提升" class="headerlink" title="let声明变量不会提升"></a>let声明变量不会提升</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)<span class="comment">//Error</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="暂时性死区TDZ"><a href="#暂时性死区TDZ" class="headerlink" title="暂时性死区TDZ"></a>暂时性死区TDZ</h3><blockquote>
<p>ES6规定在某个区块中， 一旦用let或const声明一个变量，那么这个区块就变成块级作用域，用let或const声明的变量就“绑定”这个区域，不再受外部的影响。 在该变量声明之前不可以用，在语法上我们叫这种情况为：暂时性死区 (temporal dead zone，简称 TDZ)。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">    <span class="keyword">let</span> v = <span class="number">2</span>; <span class="comment">//不能和全局变量声明相同</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(v);</span><br></pre></td></tr></table></figure>

<p>上面代码中，存在全局变量v，但是块级作用域内let又声明了一个局部变量v，导致后者绑定这个块级作用域，所以在let声明变量之前，使用v会报错。</p>
<h3 id="const关键字，用来声明一个只读的常量"><a href="#const关键字，用来声明一个只读的常量" class="headerlink" title="const关键字，用来声明一个只读的常量"></a>const关键字，用来声明一个只读的常量</h3><p>const和let类似，但是，const常量一旦声明，常量将不能重新赋值</p>
<p>使用const来定义常量，为了便于区分，通常会使用大写字母</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ABC = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ABC);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ABC = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ABC)<span class="comment">//Error</span></span><br></pre></td></tr></table></figure>

<p><strong>从本质上来说，const并不是值不能被改变，而是指向的那个内存地址不能被改变</strong></p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">box.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line">box.onclick = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用箭头函数比写原来的的function写法简洁许多（针对匿名函数使用）</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="keyword">let</span> box = <span class="function"><span class="params">value</span> =&gt;</span> value</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>箭头函数和传统函数的区别</strong></li>
</ul>
<h3 id="1，对this的关联，函数内部的指向"><a href="#1，对this的关联，函数内部的指向" class="headerlink" title="1，对this的关联，函数内部的指向"></a>1，对this的关联，函数内部的指向</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'xh'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'xm'</span>,</span><br><span class="line">    say: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say();<span class="comment">//xh</span></span><br></pre></td></tr></table></figure>

<p>实际原因是箭头函数没有自己的this，</p>
<p>他的this是继承外面的因此内部的this就是外层代码块的this</p>
<h3 id="2，new不可用"><a href="#2，new不可用" class="headerlink" title="2，new不可用"></a>2，new不可用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> test();</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//es6</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> test();<span class="comment">//Error</span></span><br></pre></td></tr></table></figure>

<h3 id="3，this不可变，this在函数体内整个执行环境为常量，不可改变this的指向"><a href="#3，this不可变，this在函数体内整个执行环境为常量，不可改变this的指向" class="headerlink" title="3，this不可变，this在函数体内整个执行环境为常量，不可改变this的指向"></a>3，this不可变，this在函数体内整个执行环境为常量，不可改变this的指向</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">'hello'</span>,</span><br><span class="line">    age: <span class="number">33</span></span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;.bind(obj1),<span class="number">1000</span>); <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<h3 id="4，没有arguments对象"><a href="#4，没有arguments对象" class="headerlink" title="4，没有arguments对象"></a>4，没有arguments对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//es6</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//报错</span></span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><blockquote>
<p>ES6中字符串模板使用反引号 <code></code> 表示，字符串模板中可以解析变量和函数，使用 ${ } 解析</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sname = <span class="string">"小明"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnAge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">`大家好，我叫<span class="subst">$&#123;sname&#125;</span>,我今年<span class="subst">$&#123;fnAge()&#125;</span>岁了`</span>;</span><br><span class="line">alert( str );</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字符串模板非常有用，当我们要插入大段的html内容到文档中时，传统的写法非常麻烦</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);</span><br><span class="line"><span class="keyword">var</span> val1 = <span class="number">11</span>, val2 = <span class="number">22</span>, val3 = <span class="number">33</span>;</span><br><span class="line">box.innerHTML = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;<span class="subst">$&#123;val1&#125;</span>&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;<span class="subst">$&#123;val2&#125;</span>&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;<span class="subst">$&#123;val3&#125;</span>&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>

<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><blockquote>
<p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span> , y = <span class="number">20</span> , z = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//es6</span></span><br><span class="line"><span class="keyword">var</span>[x,y,z] = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = <span class="string">'ken'</span>;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="string">'lili'</span>;</span><br><span class="line"><span class="keyword">var</span> zoo = &#123;<span class="attr">cat</span>: cat, <span class="attr">dog</span>: dog&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(zoo);</span><br><span class="line"></span><br><span class="line"><span class="comment">//es6</span></span><br><span class="line"><span class="keyword">let</span> cat =<span class="string">'ken'</span>;</span><br><span class="line"><span class="keyword">let</span> dog =<span class="string">'xx'</span>;</span><br><span class="line"><span class="keyword">let</span> zoo = &#123;cat,dog&#125;</span><br><span class="line"><span class="built_in">console</span>.log(zoo)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解构赋值可以作用在函数的参数上面，让函数的参数值的传递顺序发生改变</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">&#123;sname,age&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`大家好，我叫<span class="subst">$&#123;sname&#125;</span>,我今年<span class="subst">$&#123;age&#125;</span>了`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn(&#123;<span class="attr">age</span>:<span class="number">20</span>,<span class="attr">sname</span>:<span class="string">'mike'</span>&#125;))</span><br></pre></td></tr></table></figure>

<h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><blockquote>
<p>将含有length属性，以数字为key的对象，类数组转换成真正的数组</p>
<p>Array.from(obj,map函数);</p>
</blockquote>
<p><strong>将lis集合（类数组）转成 数组</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"li"</span>);</span><br><span class="line">lis = <span class="built_in">Array</span>.from(lis);</span><br><span class="line"><span class="built_in">console</span>.log( lis )</span><br><span class="line">lis.push(<span class="string">'abc'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(lis);</span><br></pre></td></tr></table></figure>

<p><strong>将对象转成 数组</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">"0"</span> : <span class="number">10</span> ,</span><br><span class="line">    <span class="string">"1"</span> : <span class="number">20</span> ,</span><br><span class="line">    <span class="string">"2"</span> : <span class="number">30</span> ,</span><br><span class="line">    <span class="string">"length"</span> : <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from( obj );</span><br><span class="line"><span class="built_in">console</span>.log( arr );</span><br></pre></td></tr></table></figure>

<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><blockquote>
<p>扩展运算符用三个点号表示，其功能是把数组或类数组对象（部署了iterator接口）展开成一系列用逗号隔开的参数序列</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>);<span class="comment">//12345</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];       </span><br><span class="line">arr1.push(...arr2)</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>rest运算符也是三个点，其功能与扩展运算符恰好相反，把逗号隔开的参数序列组合成一个数组</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">...args</span>) </span>&#123;<span class="comment">// rest运算符 组合数组</span></span><br><span class="line"><span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;;</span><br><span class="line">fn(...arr);<span class="comment">// 扩展运算符 展开数组</span></span><br><span class="line"><span class="built_in">console</span>.log(...arr);<span class="comment">//123</span></span><br></pre></td></tr></table></figure>

<h2 id="set函数"><a href="#set函数" class="headerlink" title="set函数"></a>set函数</h2><blockquote>
<p>Set 是一个构造函数，用来生成 Set 数据结构，它类似于数组，但是成员的值都是唯一的、没有重复的， 初始化 Set 可以接受一个数组或类数组对象作为参数，也可以创建一个空的 Set</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s1 = new Set();</span><br><span class="line">var s2 = new Set([1, 2, 3]);</span><br><span class="line">console.log(s1);</span><br><span class="line">console.log(s2);</span><br></pre></td></tr></table></figure>

<p>在 Set 中成员的值是唯一的，重复的值自动被过滤掉</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(s1);<span class="comment">//1234</span></span><br></pre></td></tr></table></figure>

<p>Set 的一些属性方法：</p>
<p>size：返回成员总数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = new Set([1,2]);</span><br><span class="line"><span class="keyword">set</span>.add(3);// 添加成员</span><br><span class="line">console.log(<span class="keyword">set</span>.size);// 3 成员总数</span><br><span class="line">console.log(<span class="keyword">set</span>);// Set(3) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>add(value)：添加某个值，返回Set结构本身</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>.add([4,5]);// 添加成员</span><br><span class="line">console.log(<span class="keyword">set</span>.size);// 4 成员总数</span><br><span class="line">console.log(<span class="keyword">set</span>.has(2));// true 有该成员</span><br><span class="line">console.log(<span class="keyword">set</span>);// Set(4) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]&#125;</span><br></pre></td></tr></table></figure>

<p>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功</p>
<p>has(value)：返回一个布尔值，表示该值是否为Set的成员</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>.delete(2);// 删除成员</span><br><span class="line">console.log(<span class="keyword">set</span>);// Set(3) &#123;<span class="number">1</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">set</span>.has(2));// false 没有该成员</span><br></pre></td></tr></table></figure>

<p>clear()：清除所有成员，没有返回值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>.clear();// 清除所有成员</span><br><span class="line">console.log(<span class="keyword">set</span>);// Set(0) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>for/of 与 for/in</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for/in：遍历键</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);<span class="comment">//0 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'javascript'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for/of：遍历值</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);<span class="comment">//4 5 6 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="symbol类型"><a href="#symbol类型" class="headerlink" title="symbol类型"></a>symbol类型</h2><blockquote>
<p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。</p>
<p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。</p>
</blockquote>
<p><strong>Symbol 是 JavaScript 语言的第七种数据类型。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>(<span class="string">'xm'</span>);</span><br><span class="line"><span class="built_in">console</span>.log( s ); <span class="comment">// Symbol(xm)</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">typeof</span> s );<span class="comment">// symbol</span></span><br></pre></td></tr></table></figure>

<p>对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xm = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    [xm] : <span class="string">"小明"</span> <span class="comment">//对象的属性是Symbol类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Symbol类型的属性 取值是 必须<code>obj[xm]</code> 不能用<code>obj.xm</code></p>
<p><code>console.log( obj[xm] );</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s4 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'xm'</span>,</span><br><span class="line">    [s4]: <span class="string">'xh'</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">'age'</span>)]: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;name: "xm", Symbol(): "xh", Symbol(age): 18&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// xm</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[s4]); <span class="comment">// xh 访问对象的Symbol属性的值</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="built_in">Symbol</span>(<span class="string">'age'</span>)]); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>对象的Symbol属性不会被遍历出来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">"sname"</span>:<span class="string">"小明"</span>,</span><br><span class="line">    <span class="string">"skill"</span> : <span class="string">"web"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> age = <span class="built_in">Symbol</span>();</span><br><span class="line">obj[age] = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.log( obj );</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> key <span class="keyword">in</span> obj )&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">" -&gt; "</span> + obj[key] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Object.getOwnPropertySymbols 方法会返回当前对象的所有 Symbol 属性，返回数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">"id"</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [id]: <span class="string">'007'</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">'name'</span>)]: <span class="string">'xiaocuo'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[Symbol(id),Symbol(name)]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[arr[<span class="number">1</span>]]);  <span class="comment">//'xiaocuo'  访问对象的Symbol属性的值</span></span><br></pre></td></tr></table></figure>

<p>虽然这样保证了Symbol的唯一性，但我们不排除希望能够多次使用同一个symbol值的情况。</p>
<p>官方提供了全局注册并登记的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="built_in">Symbol</span>.for(<span class="string">'name'</span>); <span class="comment">//检测到未创建后新建 </span></span><br><span class="line"><span class="keyword">let</span> name2 = <span class="built_in">Symbol</span>.for(<span class="string">'name'</span>); <span class="comment">//检测到已创建后返回 </span></span><br><span class="line"><span class="built_in">console</span>.log(name1 === name2); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    age: <span class="number">17</span>,</span><br><span class="line">    [name1]: <span class="string">'xm'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj2[name1]);<span class="comment">//'xm'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2[name2]);<span class="comment">//'xm'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2[<span class="built_in">Symbol</span>(<span class="string">'name'</span>)]);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2[<span class="built_in">Symbol</span>.for(<span class="string">'name'</span>)]);<span class="comment">//'xm'</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>知识点</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>Git版本管理工具</title>
    <url>/2019/11/01/Git%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<blockquote>
<p> Git是目前世界上最先进的分布式版本控制系统。</p>
<p>GIT为分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库适合分布式开发，强调个体公共服务器压力和数据量都不会太大速度快灵活可以离线工作操作复杂，代码保密性差</p>
</blockquote><a id="more"></a>
<h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><h3 id="一，初始化"><a href="#一，初始化" class="headerlink" title="一，初始化"></a>一，初始化</h3><p>命令  <code>git init</code></p>
<p>显示成功后去相应的文件夹中查看是不是多了一个.git隐藏文件</p>
<p>这个文件夹就是你的版本库了，把项目放在文件夹下。</p>
<h3 id="二，提交到本地暂存"><a href="#二，提交到本地暂存" class="headerlink" title="二，提交到本地暂存"></a>二，提交到本地暂存</h3><p><strong>*提交之前需要记住先刷新原有代码！！</strong></p>
<p>命令 <strong>git pull</strong>   刷新再提交  这一步很重要！</p>
<p>命令 git add ‘文件名’        </p>
<p>​         git add -u   提交所有被修改(modified)和被删除(deleted)文件，不包括新文件(new)        </p>
<p>​         git add .      提交所有新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件        </p>
<p>​         git add -A   提交所有变化</p>
<h3 id="三，提交到本地仓库"><a href="#三，提交到本地仓库" class="headerlink" title="三，提交到本地仓库"></a>三，提交到本地仓库</h3><p>命令  git commit -m ‘一段注释内容’</p>
<h3 id="四，查看仓库状态"><a href="#四，查看仓库状态" class="headerlink" title="四，查看仓库状态"></a>四，查看仓库状态</h3><p>命令  git status  用于显示工作目录和暂存区的状态。</p>
<p><strong>查看修改内容</strong></p>
<p>命令  git diff 你的文件名</p>
<p>将更改后的东西提交上去，和之前一样。先add 然后再commit</p>
<h3 id="五，版本回退"><a href="#五，版本回退" class="headerlink" title="五，版本回退"></a>五，版本回退</h3><p><strong>查看提交日志</strong></p>
<p>命令  <code>git log</code> <code>git reflog</code></p>
<p><strong>回退版本</strong></p>
<p>命令   <code>git reset --hard HEAD^</code> 退回到上个版本 </p>
<p>如果需要退回好多版本就在后面加上 ^ 例： <code>git reset --hard HEAD^^</code>退回两个版本。</p>
<p><code>git reset --hard 191e0c7</code>  回退到指定版本然后去查看readme.txt是否成功退回。</p>
<h3 id="六，提交远程仓库"><a href="#六，提交远程仓库" class="headerlink" title="六，提交远程仓库"></a>六，提交远程仓库</h3><p>命令1. git remote add origin <a href="https://github.com/你的账号/你的项目名" target="_blank" rel="noopener">https: // github.com/你的账号/你的项目</a><a href="https://github.com/你的账号/你的项目名" target="_blank" rel="noopener">名</a>称   设置远程仓库地址<br>命令2. git push -u origin master 将本地的库推送到master分支 （就是推送到服务器上）</p>
<p><code>git remote -v</code>  查看远程仓库地址</p>
<p><code>git remote rm origin</code>  删除远程仓库地址</p>
<p>第一次需要这么操作，以后就是直接 <strong>git push</strong>就行</p>
<hr>
<h2 id="操作指令总结"><a href="#操作指令总结" class="headerlink" title="操作指令总结"></a>操作指令总结</h2><blockquote>
<p><strong>git init</strong>                                  项目文件初始化</p>
<p><strong>git pull</strong>                                  提交前的刷新操作，新建仓库可以忽略</p>
<p><strong>git add -A</strong>                             提交到暂存仓库</p>
<p><strong>git commit -m ‘</strong>一段注释’  提交到本地仓库</p>
<p><strong>git status</strong>                              查看仓库状态 </p>
<p>git reflog                                查看日志</p>
<p>git reset –hard HEAD^        退回到上个版本 </p>
<p>git remote add origin <a href="https://github.com/你的账号/你的项目名" target="_blank" rel="noopener">https: // github.com/你的账号/你的项目</a><a href="https://github.com/你的账号/你的项目名" target="_blank" rel="noopener">名</a>称  <strong>第一次创建需要</strong></p>
<p>git push -u origin master 将本地的库推送到master分支                  <strong>第一次创建需要</strong></p>
<p>git remote -v                      查看远程仓库地址</p>
<p>git remote rm origin           删除远程仓库地址</p>
<p><strong>git push</strong>                                日常提交指令（master）</p>
<p>git clone <a href="https://github.com/账号/项目名称" target="_blank" rel="noopener">https://github.com/账号/项目名称</a></p>
</blockquote>
<h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><blockquote>
<p>查看分支：git branch</p>
<p>创建分支：git branch  name</p>
<p>切换分支：git checkout name</p>
<p>创建并切换分支：git checkout -b name</p>
<p>合并某分支到当前分支：git merge name</p>
<p>删除分支：git branch -d name</p>
<p><strong>提交分支</strong>：git push origin name</p>
<p><strong>拉取远程分支</strong>：git fetch origin name</p>
<p><strong>更新远程分支</strong>：git pull origin name</p>
</blockquote>
<p><strong>合并分支（工作流程）</strong></p>
<blockquote>
<p>1、先建一个分支                  git branch 分支名</p>
<p>2、切换到新建的分支          git checkout 分支名</p>
<p>3、提交分支上的代码          git add .    git commit -m “提交注释”</p>
<p>4、切换至主分支上              git checkout master</p>
<p>5、然后合并分支                  git merge 分支名字</p>
<p>6、合并完以后就push         最好先pull一次  然后 git push</p>
</blockquote>
<h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>新建文件：.gitignore.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># .gitignore 忽略文件列表</span><br><span class="line">.DS_Store</span><br><span class="line">node_modules/</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>项目相关</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>笔记</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Sass</title>
    <url>/2019/10/31/Sass/</url>
    <content><![CDATA[<h2 id="Sass是什么"><a href="#Sass是什么" class="headerlink" title="Sass是什么"></a>Sass是什么</h2><blockquote>
<ul>
<li><p>SASS是一种动态的CSS（CSS预处理器），它扩展了 CSS 语法，</p>
</li>
<li><p>定义了一套新的语法规则和函数，以加强和提升CSS。</p>
</li>
<li><p>浏览器不认识sass，都需要编译成css文件！！</p>
</li>
<li><p>你仍然可以在Sass中写普通的CSS语句！</p>
</li>
</ul>
</blockquote><a id="more"></a>
<p>Sass 扩展了 css 的特性：</p>
<p>变量嵌套规则</p>
<p>@import导入样式</p>
<p>@mixin 混合器及传参</p>
<p>@extend 继承</p>
<p>@if、@for、@function 等</p>
<h3 id="软件方式编译"><a href="#软件方式编译" class="headerlink" title="软件方式编译"></a>软件方式编译</h3><p>使用Koala编译sass</p>
<p>koala是一个国产免费前端预处理器语言图形编译工具，支持Less、Sass、Compass、CoffeeScript，帮助web开发者更高效地使用它们进行开发。跨平台运行，完美兼容windows、linux、mac。</p>
<p>koala：<a href="http://koala-app.com/index-zh.html" target="_blank" rel="noopener">http://koala-app.com/index-zh.html</a></p>
<p><strong>注：以下均为scss语法</strong></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote>
<p>sass使用$符号来标识变量</p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$nav-color</span>: <span class="number">#F90</span>;</span><br><span class="line"><span class="variable">$width</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$nav-color</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译后</span></span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#F90</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><blockquote>
<p>在Sass中，你可以像俄罗斯套娃那样在规则块中嵌套规则块。</p>
<p>Sass允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器。</p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="selector-tag">h1</span>&#123;<span class="comment">//通过缩进用于嵌套</span></span><br><span class="line">        <span class="attribute">text-align</span>:center;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">span</span>&#123;</span><br><span class="line">        <span class="attribute">font-size</span>:<span class="number">16px</span>;</span><br><span class="line">        <span class="selector-tag">a</span>&#123;</span><br><span class="line">            <span class="attribute">color</span>:blue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//编译后</span><br><span class="line"><span class="number">#b</span>ox &#123;</span><br><span class="line">    width: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#box</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#box</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#box</span> <span class="selector-tag">span</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父选择器的标识符 <strong>&amp;</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>:red;</span><br><span class="line">    &amp;:hover&#123;</span><br><span class="line">        <span class="attribute">font-size</span>:<span class="number">60px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译后</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>:hover &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="import导入样式"><a href="#import导入样式" class="headerlink" title="@import导入样式"></a>@import导入样式</h3><blockquote>
<p>css有一个特别不常用的特性，即@import url()规则，它允许在一个css文件中导入其他css文件。 页面打开时，link引用的css文件被加载。而@import引用的CSS等页面加载完(DOM)之后再加载。</p>
</blockquote>
<blockquote>
<p>sass也有一个@import规则，但不同的是，sass的@import规则在生成css文件时就把相关文件导入进来。@import “b”;这条命令将把 b.scss文件中所有样式添加到当前样式表中</p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.scss</span></span><br><span class="line"><span class="variable">$width</span> : <span class="number">100px</span>;</span><br><span class="line"><span class="selector-class">.before</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">"b"</span>;</span><br><span class="line"><span class="selector-class">.after</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">$height</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.scss</span></span><br><span class="line"><span class="variable">$width</span> : <span class="number">200px</span>;</span><br><span class="line"><span class="variable">$height</span> : <span class="number">200px</span></span><br></pre></td></tr></table></figure>

<p><strong>编译后</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.css</span></span><br><span class="line"><span class="selector-class">.before</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.after</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="混合器-mixin"><a href="#混合器-mixin" class="headerlink" title="混合器 @mixin"></a>混合器 @mixin</h3><blockquote>
<p>你可以通过sass的混合器实现大段样式的重用。</p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> no-bullets &#123;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">    <span class="selector-tag">li</span> &#123;</span><br><span class="line">        <span class="attribute">list-style-image</span>: none;</span><br><span class="line">        <span class="attribute">list-style-type</span>: none;</span><br><span class="line">        <span class="attribute">margin-left</span>: <span class="number">0px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.plain</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">    @<span class="keyword">include</span> no-bullets;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后：</span></span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.plain</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.plain</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">list-style-image</span>: none;</span><br><span class="line">    <span class="attribute">list-style-type</span>: none;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>还可以给混合器传参</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> link-colors(<span class="variable">$normal</span>, <span class="variable">$hover</span>, <span class="variable">$visited</span>) &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$normal</span>;</span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="variable">$hover</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;:visited &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="variable">$visited</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    @<span class="keyword">include</span> link-colors(blue, red, green);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后：</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>:hover &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>:visited &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承-extend"><a href="#继承-extend" class="headerlink" title="继承@extend"></a>继承@extend</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fdd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">    @<span class="keyword">extend</span> .error; <span class="comment">//继承所有样式</span></span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后：</span></span><br><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fdd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fdd</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="颜色函数"><a href="#颜色函数" class="headerlink" title="颜色函数"></a>颜色函数</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$color</span>要改变的颜色，<span class="variable">$amount</span>取值范围是0~100%</span><br><span class="line">lighten(<span class="variable">$color</span>, <span class="variable">$amount</span>) <span class="comment">//颜色变浅函数；</span></span><br><span class="line">darken(<span class="variable">$color</span>, <span class="variable">$amount</span>) <span class="comment">//颜色变深函数；</span></span><br><span class="line"></span><br><span class="line">saturate(<span class="variable">$color</span>, <span class="variable">$amount</span>) <span class="comment">//增加颜色的饱和度；</span></span><br><span class="line">desaturate(<span class="variable">$color</span>, <span class="variable">$amount</span>) <span class="comment">//减少颜色的饱和度；</span></span><br><span class="line">grayscale(<span class="variable">$color</span>) <span class="comment">//将该颜色转换为相对应的灰度颜色；</span></span><br><span class="line">complement(<span class="variable">$color</span>) <span class="comment">//获取该颜色值旋转180度后相对应的颜色；</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>进阶提升</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>sass</tag>
        <tag>css扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>gulp</title>
    <url>/2019/10/30/gulp/</url>
    <content><![CDATA[<h2 id="什么是Gulp"><a href="#什么是Gulp" class="headerlink" title="什么是Gulp"></a>什么是Gulp</h2><blockquote>
<p>Gulp是基于Node.js流的前端自动化构建工具</p>
<p>Gulp自动化构建工具可以增强你的工作流程！易于使用、易于学习、构建快速、插件高质！</p>
<p>在日常开发中，可以借助Gulp的一些插件完成很多的前端任务。</p>
<p>如：代码的编译（sass、less）、压缩css，js、图片、合并js，css、es6转es5、自动刷新页面等。</p>
</blockquote><a id="more"></a>
<h2 id="使用Gulp"><a href="#使用Gulp" class="headerlink" title="使用Gulp"></a>使用Gulp</h2><p>第一步先确保根目录存在 <code>package.json</code> 文件，执行 <code>npm init -y</code> 生成</p>
<p><strong>1. 全局安装gulp-cli脚手架</strong></p>
<p><code>npm install gulp-cli --global</code></p>
<p><strong>2. 安装项目开发依赖</strong></p>
<p><code>npm install gulp --save-dev</code></p>
<p><strong>3.在项目根目录下创建一个名为 gulpfile.js 的配置文件：</strong></p>
<p>此文件是项目主文件，运行gulp命令时，默认运行此文件</p>
<p><strong>4.命令行运行 gulp：</strong></p>
<p>gulp + 任务名</p>
<hr>
<h2 id="Gulp常用的API"><a href="#Gulp常用的API" class="headerlink" title="Gulp常用的API"></a>Gulp常用的API</h2><blockquote>
<p>task()、src()、dest()、watch()、series()、parallel()</p>
</blockquote>
<p><strong>gulp.task 方法用来注册任务</strong></p>
<blockquote>
<p>gulp.task(taskName, taskFunction)</p>
<p>taskName 为任务名</p>
<p>taskFunction 为任务函数，我们把任务要执行的代码都写在里面。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line">gulp.task(<span class="string">'task1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//注册任务task1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行task1'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>新版本<a href="mailto:Gulp@4.0" target="_blank" rel="noopener">Gulp@4.0</a>书写方式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTask</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行task2'</span>);</span><br><span class="line">    done(); <span class="comment">//异步任务完成</span></span><br><span class="line">&#125;</span><br><span class="line">exports.task2 = myTask; <span class="comment">//注册任务task2</span></span><br></pre></td></tr></table></figure>

<p><strong>gulp.dest 创建一个流，用于从文件系统读取元数据对象</strong>（用来读取文件）</p>
<blockquote>
<p>gulp.src(‘./js/a.js’); // 读取一个文件</p>
<p>gulp.src(‘./js/*.js’); // 读取js目录下的所有js文件</p>
<p>gulp.src([‘./js/a.js’,’./js/b.js’]); // 读取两个文件</p>
</blockquote>
<p><strong>gulp.dest 创建一个流，用于将元数据对象写入到文件系统</strong>（设置生成文件的路径）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line">gulp.task(<span class="string">'mytask'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">"./js/a.js"</span>)</span><br><span class="line">    .pipe(gulp.dest(<span class="string">"./dist"</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>读取文件流（gulp.src），通过管道（pipe），把文件流写入（gulp.dest）当前目录下的 dist 文件夹中</p>
<p><strong>gulp.watch  监听 globs 并在发生更改时运行任务</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'watchs'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//监听任务</span></span><br><span class="line">    <span class="comment">//当匹配任务变化时执行相应任务</span></span><br><span class="line">    gulp.watch(<span class="string">'./js/*.js'</span>,gulp.series(<span class="string">'concat'</span>));</span><br><span class="line">    gulp.watch(<span class="string">'./css/*.css'</span>,gulp.series(<span class="string">'task1'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>gulp.series() 将任务函数或组合操作组合成更大的操作（按顺序执行，同步）</strong></p>
<p><strong>gulp.parallel() 将任务函数或组合操作组合成更大的操作（同时进行，异步）</strong></p>
<hr>
<h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><p>常见问题解决方案：清理残留缓存<code>npm cache clean --force</code></p>
<p><strong>文件合并</strong></p>
<p>安装：<code>npm install --save-dev gulp-concat</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> concat = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>); <span class="comment">//引入插件</span></span><br><span class="line">gulp.task(<span class="string">'concat'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./js/*.js'</span>) 	<span class="comment">//要合并的文件</span></span><br><span class="line">    .pipe(concat(<span class="string">'main.js'</span>)) 		<span class="comment">//合并匹配到的js文件并命名为 "main.js"</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist/js'</span>));	<span class="comment">//写入dist/js文件夹下</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>js文件压缩</strong></p>
<p>安装：<code>npm install --save-dev gulp-uglify</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>); <span class="comment">//引入插件</span></span><br><span class="line">gulp.task(<span class="string">'uglifyJS'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./dist/main.js'</span>) <span class="comment">// 要压缩的js文件</span></span><br><span class="line">    .pipe(uglify()) 				<span class="comment">//使用uglify进行压缩</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist/js'</span>));	<span class="comment">//写入js文件夹</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>css文件压缩</strong></p>
<p>安装：<code>npm install --save-dev gulp-minify-css</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> minifyCss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);<span class="comment">//引入插件</span></span><br><span class="line">gulp.task(<span class="string">'minifyCss'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./dist/main.css'</span>) <span class="comment">// 要压缩的css文件</span></span><br><span class="line">    .pipe(minifyCss()) 				<span class="comment">//压缩css</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist/css'</span>));	<span class="comment">//写入dist文件夹</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>css/js文件合并压缩</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>); <span class="comment">//引入js压缩插件</span></span><br><span class="line"><span class="keyword">var</span> concat = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>); <span class="comment">//引入合并插件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//js文件的合并压缩</span></span><br><span class="line">gulp.task(<span class="string">'concatJs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src([<span class="string">'./js/*.js'</span>, <span class="string">'!./js/j*.js'</span>]) <span class="comment">//要合并的文件</span></span><br><span class="line">        .pipe(concat(<span class="string">'main.js'</span>)) 		<span class="comment">//合并匹配到的js文件并命名为 "main.js"</span></span><br><span class="line">        .pipe(uglify())					<span class="comment">//将合并后的js文件进行压缩</span></span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./dist/js'</span>))<span class="comment">//写入dist/js文件夹</span></span><br><span class="line">        .pipe(connect.reload())</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>html文件压缩</strong></p>
<p>安装：<code>npm install --save-dev gulp-minify-html</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> minifyHtml = <span class="built_in">require</span>(<span class="string">'gulp-minify-html'</span>);<span class="comment">//引入插件</span></span><br><span class="line">gulp.task(<span class="string">'minifyHtml'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./test.html'</span>) <span class="comment">//要压缩的html文件</span></span><br><span class="line">    .pipe(minifyHtml()) 			<span class="comment">//压缩html</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist/'</span>));	<span class="comment">//写入dist文件夹</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>重命名</strong></p>
<p>安装：<code>npm install --save-dev gulp-rename</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">var</span> rename = <span class="built_in">require</span>(<span class="string">'gulp-rename'</span>);<span class="comment">//引入插件</span></span><br><span class="line">gulp.task(<span class="string">'rename'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./js/jquery-1.8.3.js'</span>) <span class="comment">//读取文件</span></span><br><span class="line">    .pipe(uglify()) 						<span class="comment">//压缩</span></span><br><span class="line">    .pipe(rename(<span class="string">'jquery-1.8.3.min.js'</span>))	<span class="comment">//重命名</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist/js'</span>));			<span class="comment">//写入js文件夹</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><strong>ES6转ES5</strong></p>
<p>安装：<code>npm install --save-dev gulp-babel @babel/core @babel/preset-env</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</span><br><span class="line">gulp.task(<span class="string">'es6Toes5'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./js/class.js'</span>)</span><br><span class="line">    .pipe(babel(&#123; <span class="attr">presets</span>: [<span class="string">'@babel/preset-env'</span>]&#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist/js'</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>sass编译</strong></p>
<p>安装：<code>npm install --save-dev gulp-sass</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">"gulp-sass"</span>);</span><br><span class="line">gulp.task(<span class="string">'sass'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./test.scss'</span>)</span><br><span class="line">    .pipe(sass())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'compileSass'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.watch(<span class="string">'./test.scss'</span>,gulp.series(<span class="string">'sass'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><strong>*自动刷新</strong></p>
<p>安装：<code>npm install --save-dev gulp-connect</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);<span class="comment">//gulp包</span></span><br><span class="line"><span class="keyword">const</span> minifyHtml = <span class="built_in">require</span>(<span class="string">'gulp-minify-html'</span>);<span class="comment">//压缩html</span></span><br><span class="line"><span class="keyword">const</span> connect = <span class="built_in">require</span>(<span class="string">'gulp-connect'</span>);<span class="comment">//浏览器刷新插件</span></span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'reload'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    connect.server(&#123;</span><br><span class="line">        livereload: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    done();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'minifyHtml'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./test.html'</span>)  <span class="comment">//要压缩的html文件</span></span><br><span class="line">    .pipe(minifyHtml()) 			<span class="comment">//压缩html</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist'</span>))		<span class="comment">//写入dist文件夹</span></span><br><span class="line">    .pipe(connect.reload())<span class="comment">//自动刷新的关键，css合并压缩和js合并压缩都要加上这一句，就不一一举例了</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监视文件的状态并同步更新</span></span><br><span class="line">gulp.task(<span class="string">'watchs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.watch(<span class="string">'./css/*.css'</span>, gulp.series(<span class="string">'concatCss'</span>))  <span class="comment">//监视 并同步css  压缩代码</span></span><br><span class="line">    gulp.watch(<span class="string">'./js/*.js'</span>, gulp.series(<span class="string">'concatJs'</span>))     <span class="comment">//监视 并同步js   压缩代码   </span></span><br><span class="line">    gulp.watch(<span class="string">'./*.html'</span>, gulp.series(<span class="string">'minifyHtml'</span>))    <span class="comment">//监视 并同步html 压缩代码   </span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'run'</span>, gulp.series(<span class="string">'reload'</span>, <span class="string">'watchs'</span>));</span><br></pre></td></tr></table></figure>

<p><strong>*一键打包</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'bulid'</span>, gulp.parallel( <span class="comment">//一键打包生成</span></span><br><span class="line">    gulp.series(<span class="string">'concatCss'</span>),</span><br><span class="line">    gulp.series(<span class="string">'concatJs'</span>),</span><br><span class="line">    gulp.series(<span class="string">'rename'</span>),</span><br><span class="line">    gulp.series(<span class="string">'minifyHtml'</span>)</span><br><span class="line">));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>项目相关</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>笔记</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>npm的使用</title>
    <url>/2019/10/30/npm%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><strong>NPM是随同NodeJS一起安装的包管理工具，包的结构使您能够轻松跟踪依赖项和版本。</strong></p><blockquote>
<p>NPM能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p>
<p>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</p>
<p>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</p>
<p>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</p>
</blockquote><a id="more"></a>

<p><strong>项目初始化：</strong> package.json 配置文件</p>
<p><code>$ npm init -y  跳过所有提问</code></p>
<p><strong>安装包</strong></p>
<p>本地安装 <code>$ npm install 包名</code></p>
<p>全局安装<code>$ npm install 包名 -global</code></p>
<p>缩写形式<code>$ npm i 包名 -g</code></p>
<p><strong>项目依赖</strong></p>
<p> <code>$ npm install 包名 -save</code></p>
<p>项目上线需要用到的包，缩写<code>$ npm install 包名 -S (大写)</code></p>
<p><strong>开发依赖</strong></p>
<p><code>$ npm install 包名 --save-dev</code></p>
<p>开发测试需要用到的包，缩写 <code>$ npm install 包名 -D (大写)</code></p>
<p><strong>移除依赖模块</strong></p>
<p><code>$ npm uninstall 包名 -save</code></p>
<p><code>$ npm uninstall 包名 --save-dev</code></p>
<p><strong>清除缓存数据</strong></p>
<p><code>npm cache verify</code></p>
]]></content>
      <categories>
        <category>项目相关</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>npm</tag>
        <tag>操作指令</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js的初步认识</title>
    <url>/2019/10/29/nodeJs%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<h2 id="Node-js简介"><a href="#Node-js简介" class="headerlink" title="Node.js简介"></a>Node.js简介</h2><blockquote>
<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。</p>
<p>Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。</p>
<p>简单的说 Node.js 就是运行在服务端的 JavaScript</p>
<p>Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。</p>
</blockquote><a id="more"></a>
<p><strong>node.js三大特点：</strong></p>
<p><strong>1.单线程</strong></p>
<blockquote>
<p>Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。</p>
</blockquote>
<p><strong>2.非阻塞I/O(异步)</strong></p>
<blockquote>
<p>阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。</p>
<p>这是一种特别有哲理的解决方案：<strong>与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。</strong></p>
</blockquote>
<p><strong>3.事件驱动</strong></p>
<blockquote>
<p>在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件循环”机制。</p>
<p>用事件驱动来完成服务器的任务调度，用一个线程，担负起了处理非常多的任务的使命。</p>
</blockquote>
<h2 id="搭建web服务器"><a href="#搭建web服务器" class="headerlink" title="搭建web服务器"></a>搭建web服务器</h2><p><strong>总共分为四个步骤</strong></p>
<ol>
<li><p>加载http模块    </p>
</li>
<li><p>创建http服务    </p>
</li>
<li><p>服务端对象监听request 请求事件，用于监听客户端的请求    </p>
</li>
<li><p>启动http服务，监听端口</p>
</li>
</ol>
<p><strong>参考代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);		 <span class="comment">//加载http模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer();<span class="comment">//创建http服务</span></span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; <span class="comment">//服务对象监听request 请求事件，用于监听客户端的请求</span></span><br><span class="line">  <span class="comment">//req-请求对象 , res-响应对象</span></span><br><span class="line">  <span class="comment">//处理客户端请求逻辑</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'收到请求: '</span>+ req.url); <span class="comment">//用户请求地址</span></span><br><span class="line">  res.setHeader(<span class="string">"Content-type"</span>,<span class="string">"text/plain;charset=utf-8"</span>); <span class="comment">//设置文件类型</span></span><br><span class="line">  res.end(); <span class="comment">//必须结束响应，否则浏览器会被挂起</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//启动http服务，开始监听3000端口</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'服务已经启动，请访问： http://localhost:3000 或 http://127.0.0.1:3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注意点：</strong></p>
<ol>
<li>在监听request事件中，最后一定要res.end()结束响应。</li>
<li>浏览器显示中文可能是乱码，需设置响应头告诉浏览器显示时所使用的编码，要在res.end()之前设置</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">"Content-type"</span>,<span class="string">"text/plain;charset=utf-8"</span>); <span class="comment">// 响应为纯文本</span></span><br><span class="line">res.setHeader(<span class="string">"Content-type"</span>,<span class="string">"text/html;charset=utf-8"</span>);  <span class="comment">//响应为html文本</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>node.js没有根目录、没有web容器的概念！</strong></li>
</ol>
<h2 id="node-js读写文件"><a href="#node-js读写文件" class="headerlink" title="node.js读写文件"></a>node.js读写文件</h2><p><strong>读文件</strong></p>
<p><code>fs.readFile(file[, options], callback)</code></p>
<ul>
<li>参数1：要读取的文件路径，必填。   </li>
<li>参数2：读取文件时的选项，比如：文件编码utf8。选填。 </li>
<li>参数3：文件读取完毕后的回调函数，必填。</li>
</ul>
<p><strong>注意点：</strong></p>
<ul>
<li>该操作采用异步执行    </li>
<li>回调函数有两个参数，分别是err和data    </li>
<li>如果读取文件时没有指定编码，返回的是二进制数据，如指定编码utf8，会返回指定的编码数据。    </li>
<li>只要异步操作，回调函数第一个都是错误对象err优先</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载http包(nodeJS内置包)</span></span><br><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="comment">//创建服务器  </span></span><br><span class="line"><span class="keyword">let</span> server = http.createServer()</span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); <span class="comment">//引入内部模块</span></span><br><span class="line"><span class="comment">//监听服务器的请求状态(用户发送请求触发)</span></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用户发送了请求'</span>);</span><br><span class="line">    <span class="keyword">if</span> (req.url == <span class="string">'/heihei'</span>) &#123;<span class="comment">//地址可以自定义</span></span><br><span class="line">        fs.readFile(<span class="string">'./home.html'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">                res.setHeader(<span class="string">'Content-type'</span>, <span class="string">'text/html;charset=utf-8'</span>);</span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        res.writeHead(<span class="number">404</span>, &#123; <span class="string">'Content-type'</span>: <span class="string">'text/plain;charset=utf-8'</span> &#125;);</span><br><span class="line">        res.end(<span class="string">'404,页面丢失了！！！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//启动服务，监听端口 ip地址 回调函数</span></span><br><span class="line">server.listen(<span class="string">"3000"</span>, <span class="string">"10.36.147.180"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'服务已启动，请访问：10.36.147.180:3000'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>写文件</strong></p>
<p><code>fs.writeFile(file, data[, options], callback);</code></p>
<ul>
<li>参数1：要写入的文件路径，必填</li>
<li>参数2：要写入的数据，必填</li>
<li>参数3：写入文件时的选项，比如：文件编码</li>
<li>参数4：文件写入完毕后的回调函数，必填</li>
</ul>
<p><strong>注意点：</strong></p>
<ul>
<li>该操作采用异步执行    </li>
<li>如果文件存在则替换原内容    </li>
<li>默认写入的文件编码为utf8    </li>
<li>回调函数有1个参数：err，表示在写入文件的操作过程中是否出错了。    </li>
<li>如果出错了err != null，成功时 err === null    </li>
<li>写入文件（文件不存在则自动创建）</li>
</ul>
<p>writeFile写入文件是先把文件内容清空再写入，如果要追加写入的话可以使用appendFile函数</p>
<p><strong>示例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载http包(nodeJS内置包)</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); <span class="comment">//引入内部模块</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//给用户生成一个id</span></span><br><span class="line">    <span class="keyword">var</span> userid = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.radom()*<span class="number">89999</span>)+<span class="number">10000</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用户'</span>+userid);</span><br><span class="line">    res.writeHead(<span class="number">200</span>,&#123;<span class="string">"Content-Type"</span>:<span class="string">"text/html;charset=UTF8"</span>&#125;);</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">'新修改的文字'</span>;</span><br><span class="line">    <span class="comment">//参数一是当前文件路径 参数二是写入数据</span></span><br><span class="line">    <span class="comment">//参数三是文件编码	  参数四是回调函数</span></span><br><span class="line">    fs.writeFile(<span class="string">"./test.txt"</span>,str,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(err)&#123;</span><br><span class="line">           <span class="keyword">throw</span> err;</span><br><span class="line">       &#125; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'文件写入完成'</span>);</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="string">"3002"</span>, <span class="string">"10.36.147.180"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'服务已启动，请访问：10.36.147.180:3002'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>nodeJS</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>笔记</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化编程</title>
    <url>/2019/10/28/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="ES6-module"><a href="#ES6-module" class="headerlink" title="ES6 module"></a>ES6 module</h2><blockquote>
<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD  两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
</blockquote><a id="more"></a>
<p><strong>设置浏览器启用es6语法功能：（Chrome 61+，Firefox 54+）</strong></p>
<blockquote>
<ol>
<li><p>在浏览器的url中输入：<a href="chrome://flags/" target="_blank" rel="noopener">chrome://flags/</a></p>
</li>
<li><p>搜索 JavaScript 关键字</p>
</li>
<li><p>设置选项 Experimental JavaScript 为 Enable</p>
</li>
<li><p>重启浏览器后生效</p>
</li>
</ol>
</blockquote>
<p><strong>注意事项</strong></p>
<blockquote>
<ul>
<li><p>script 标签里面要加 type=”module”, 这样浏览器才会把相关的代码当作ES6的module 来对待</p>
</li>
<li><p>不能写“裸”路径，即使是同一层级下面的文件，也要加上 ‘./name.js’</p>
</li>
<li><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”。</p>
</li>
<li><p>ES6 模块功能主要由两个命令构成：export 和 import。</p>
</li>
<li><p>export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
</li>
<li><p>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。</p>
</li>
</ul>
</blockquote>
<h3 id="export-关键字"><a href="#export-关键字" class="headerlink" title="export 关键字"></a><strong>export 关键字</strong></h3><p>如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userName = <span class="string">'xiaoming'</span>;</span><br><span class="line"><span class="keyword">var</span> userSex = <span class="string">'男'</span>;</span><br><span class="line"><span class="keyword">var</span> userAge = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; userName, userSex, userAge &#125;;</span><br></pre></td></tr></table></figure>

<p>export命令除了输出变量，还可以输出对象、函数或类（class）。</p>
<p><code>export function sum(x, y) { return x + y;};</code></p>
<p>上面代码对外输出一个函数sum</p>
<p>通常情况下，export输出的变量就是本来的名字，但是可以使用<strong>as关键字</strong>重命名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  f1 <span class="keyword">as</span> test1,</span><br><span class="line">  f2 <span class="keyword">as</span> test2,</span><br><span class="line">  f2 <span class="keyword">as</span> test3</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码使用as关键字，重命名了函数f1和f2的对外接口。重命名后，f2可以用不同的名字输出两次。</p>
<p><strong>正确的写法</strong></p>
<ul>
<li><p><code>export var m = 1;</code></p>
</li>
<li><p><code>var m = 1;  export {m};</code></p>
</li>
<li><p><code>var n = 1;    export {n as m};</code></p>
</li>
<li><p><code>export function f() {};</code></p>
</li>
<li><p><code>function f() {}export {f};</code></p>
</li>
</ul>
<h3 id="import-关键字"><a href="#import-关键字" class="headerlink" title="import 关键字"></a>import 关键字</h3><p>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; userName, userSex, userAge &#125; <span class="keyword">from</span> <span class="string">'./module1.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(userName);</span><br><span class="line"><span class="built_in">console</span>.log(userSex);</span><br><span class="line"><span class="built_in">console</span>.log(userAge);</span><br></pre></td></tr></table></figure>

<p>如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。</p>
<p><code>import { userName as xm } from &#39;./module1.js&#39;;</code></p>
<p>import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。如果a是一个对象，改写a的属性是允许的。</p>
<p><code>import {a} from &#39;./xxx.js&#39;        a.foo = &#39;hello&#39;; // 合法操作</code></p>
<p><strong>import命令具有提升效果，会提升到整个模块的头部，首先执行。</strong></p>
<p>除了指定加载某些输出值，还可以使用整体加载，即用 * 指定一个对象，所有输出值都加载在这个对象上面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> obj <span class="keyword">from</span> <span class="string">'./module1.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.userName);</span><br><span class="line"><span class="built_in">console</span>.log(obj.userSex);</span><br><span class="line"><span class="built_in">console</span>.log(obj.userAge);</span><br></pre></td></tr></table></figure>

<h3 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h3><p>为了给用户提供方便，用export default命令，为模块指定默认输出。</p>
<p>默认输出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 输出</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">'./test.js'</span>; <span class="comment">// 输入</span></span><br></pre></td></tr></table></figure>

<p>正常输出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 输出</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">import</span> &#123; test &#125; <span class="keyword">from</span> <span class="string">'./test.js'</span>; <span class="comment">// 输入</span></span><br></pre></td></tr></table></figure>

<p>使用export default时，对应的import语句不需要使用大括号；</p>
<p>不使用export default时，对应的import语句需要使用大括号。</p>
<p><strong>注意：</strong></p>
<p>一个模块只能有一个默认输出，因此export default命令只能使用一次。</p>
<p>因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<h2 id="浏览器加载规则"><a href="#浏览器加载规则" class="headerlink" title="浏览器加载规则"></a>浏览器加载规则</h2><blockquote>
<p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到script&gt;标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。</p>
</blockquote>
<p><strong>浏览器两种异步加载的语法</strong></p>
<p><code>&lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt;</code></p>
<p><code>&lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt;</code></p>
<p>上面代码中，script&gt;标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p>
<p><strong>defer与async的区别</strong></p>
<p>defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；</p>
<p>async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染</p>
<p><strong>defer是“渲染完再执行”，async是“下载完就执行”。</strong></p>
<p>如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</p>
<p>浏览器加载 ES6 模块，也使用script&gt;标签，但是要加入type=”module”属性。</p>
<p>浏览器对于带有type=”module”的script&gt;，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了script&gt;标签的defer属性。</p>
<p><code>&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot; defer&gt;&lt;/script&gt;</code></p>
<h2 id="RequireJs"><a href="#RequireJs" class="headerlink" title="RequireJs"></a>RequireJs</h2><p><strong>什么是RequireJs</strong></p>
<blockquote>
<p>RequireJS是一个非常小巧的JavaScript模块载入框架，是AMD规范最好的实现者之一。</p>
<p>AMD即Asynchronous Module Definition（异步模块定义）。</p>
<p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。</p>
<p>CMD即Common Moudle Definition（通用模块定义）。</p>
<p>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</p>
</blockquote>
<p><strong>AMD和CMD相同点：</strong></p>
<blockquote>
<ul>
<li>都是异步加载模块；</li>
<li>都实现了浏览器端模块化开发的目的；</li>
<li>都倡导模块化开发理念，使前端模块化开发变得简单自然；</li>
<li>解决前端开发过程中的两大问题：<ol>
<li>文件之间的依赖问题；</li>
<li>浏览器加载多个JS文件时页面失去响应的时间过长。</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>AMD和CMD不同点：</strong></p>
<blockquote>
<ol>
<li>官方推荐的写法不同，AMD推崇依赖前置，CMD推崇依赖就近；</li>
<li>模块的执行时机不同，AMD是提前执行，CMD是延迟执行；</li>
<li>api的设计不同，AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。</li>
</ol>
</blockquote>
<p><strong>“一个模块就是一个文件”</strong></p>
<p><strong>require 用来加载依赖模块，并执行加载完后的回调函数</strong></p>
<p><code>require([&#39;moduleA&#39;, &#39;moduleB&#39;], function (a, b){ });</code></p>
<p>第一个参数是依赖模块列表，第二个参数是一个callback函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局配置</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">'js/lib'</span>,</span><br><span class="line">    paths : &#123;</span><br><span class="line">        <span class="string">"jquery"</span> : [<span class="string">"http://libs.baidu.com/jquery/2.0.3/jquery"</span>,<span class="string">"jquery-2.1.4.min"</span>],</span><br><span class="line">        <span class="string">"mytask"</span> : <span class="string">"myTask"</span>   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">require</span>([<span class="string">"jquery"</span>,<span class="string">"mytask"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$, mytask</span>)</span>&#123;</span><br><span class="line">    $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       mytask(<span class="string">"load finished"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>require.config</strong>是用来配置模块加载位置，简单点说就是<strong>引入模块并起一个别名</strong></p>
<p>配置完成还要记得在html中设置<strong>入口文件</strong></p>
<p><code>&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;</code></p>
<p><strong>define 用来定义一个模块</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(&#123;</span><br><span class="line">　 <span class="comment">// ...</span></span><br><span class="line">    key: value</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"> </span>)</span>&#123;</span><br><span class="line">　 <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">define([<span class="string">'依赖的模块路径'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">依赖模块名称</span>)</span>&#123;</span><br><span class="line">　<span class="comment">// ...</span></span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　<span class="comment">// ...</span></span><br><span class="line">　&#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">define(<span class="string">'模块名称'</span>, [<span class="string">'依赖的模块路径'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">依赖模块名称</span>)</span>&#123;</span><br><span class="line">　<span class="comment">// ...</span></span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　<span class="comment">// ...</span></span><br><span class="line">　&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2019/10/24/Promise%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote>
<p>Promise 是ES6对异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理更强大。</p>
<p>Promise 简单说就是一个容器，里面保存着一个尚未完成且预计在未来完成的异步操作。</p>
<p>Promise 是一个构造函数，用来创建一个Promise对象。</p>
<p>有了Promise对象，就可以将<strong>异步操作以同步操作的流程表达出来</strong>，避免了层层嵌套的回调函数。</p>
</blockquote><a id="more"></a>
<h3 id="Promise对象代表一个异步操作，有三种状态："><a href="#Promise对象代表一个异步操作，有三种状态：" class="headerlink" title="Promise对象代表一个异步操作，有三种状态："></a>Promise对象代表一个异步操作，有三种状态：</h3><ul>
<li>pending（进行中）</li>
<li>fulfilled（已成功）</li>
<li>rejected（已失败）</li>
</ul>
<h3 id="Promise-对象的状态改变有两种："><a href="#Promise-对象的状态改变有两种：" class="headerlink" title="Promise 对象的状态改变有两种："></a>Promise 对象的状态改变有两种：</h3><p>从 pending 变为 fulfilled</p>
<p>从 pending 变为 rejected</p>
<hr>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。</p>
<p>resolve 和 reject 是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>resolve</strong> 函数的作用是，将Promise对象的状态从“进行中”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。</p>
<p><strong>reject</strong> 函数的作用是，将Promise对象的状态从“进行中”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<hr>
<h3 id="then和catch"><a href="#then和catch" class="headerlink" title="then和catch"></a>then和catch</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//成功执行的函数（resolve）</span></span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">    </span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rej</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//失败执行的函数（reject）</span></span><br><span class="line">    <span class="built_in">console</span>.log(rej)</span><br><span class="line">    </span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">    <span class="comment">//捕获报错信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>then</strong>有两个参数，一个是成功后的回调函数，另一个是失败后的回调函数</p>
<p><strong>catch</strong>是一个用于指定发生错误的回调函数，将报错信息捕获</p>
<h3 id="使用Promise解决定时器嵌套问题"><a href="#使用Promise解决定时器嵌套问题" class="headerlink" title="使用Promise解决定时器嵌套问题"></a>使用Promise解决定时器嵌套问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装一个Promise的定时器函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPromise</span>(<span class="params">msg, time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(msg);</span><br><span class="line">                resolve();</span><br><span class="line">            &#125;, time)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//利用getPromise函数同步执行</span></span><br><span class="line"><span class="comment">//结果为： 一 二 三 完成</span></span><br><span class="line">    getPromise(<span class="string">'第一个任务'</span>, <span class="number">1000</span>)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getPromise(<span class="string">'第二个任务'</span>, <span class="number">2000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getPromise(<span class="string">'第三个任务'</span>, <span class="number">3000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getPromise(<span class="string">'完成'</span>, <span class="number">4000</span>)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域</title>
    <url>/2019/10/23/%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="Ajax跨域"><a href="#Ajax跨域" class="headerlink" title="Ajax跨域"></a>Ajax跨域</h2><blockquote>
<p>由于浏览器的同源策略，禁止ajax从一个域名请求另外一个域名上的数据。</p>
<p>浏览器的同源策略，是对JavaScript实施的安全限制</p>
</blockquote><p><strong>所谓的同源是指，域名，协议，端口都相同</strong></p><p><a href="http://image.baidu.com/search/detail?ct=503316480&z=undefined#header" target="_blank" rel="noopener">http://image.baidu.com:80/search/detail?ct=503316480&amp;z=undefined#header</a></p><a id="more"></a>


<p>URL构成：http —- 超文本传输协议</p>
<p><a href="http://image.baidu.com/" target="_blank" rel="noopener">image.baidu.com</a> —- 域名</p>
<p>80 —- 端口</p>
<p>/search/detail —- 资源目录</p>
<p>ct=503316480&amp;z=undefined —- 发送到服务器的数据</p>
<p>#header —- 锚点</p>
<h3 id="常见的跨域解决方案"><a href="#常见的跨域解决方案" class="headerlink" title="常见的跨域解决方案"></a>常见的跨域解决方案</h3><ol>
<li><strong>通过服务端语言代理请求。</strong></li>
</ol>
<p>如PHP，服务端语言php是没有跨域限制的。 让服务器去别的网站获取内容然后返回页面。</p>
<ol start="2">
<li><p><strong>jsonp跨域</strong></p>
<ul>
<li><p>jsonp跨域就是利用script标签的跨域能力请求资源</p>
</li>
<li><p>既然叫jsonp，显然目的还是json，而且是跨域获取</p>
</li>
<li><p><strong>利用js创建一个script标签，把json的url赋给script的scr属性，把这个script插入到页面里，让浏览器去跨域获取资源</strong></p>
</li>
<li><p>callback是页面存在的回调方法，参数就是想得到的json</p>
</li>
<li><p>回调方法要遵从服务端的约定一般是用 callback 或者 cb</p>
</li>
<li><p><strong>jsonp只针对get请求</strong></p>
</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">OScript = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);<span class="comment">//创建script标签 </span></span><br><span class="line">OScript.src = <span class="string">'http://suggestion.baidu.com/su?wd='</span> + <span class="keyword">this</span>.value + <span class="string">'&amp;cb=myCallback'</span>;</span><br><span class="line"><span class="comment">//把数据地址赋值给src</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(OScript);<span class="comment">//添加到页面</span></span><br></pre></td></tr></table></figure>



<ol start="3">
<li><strong>CORS 跨域资源共享(xhr2)</strong></li>
</ol>
<p>实现CORS通信的关键是服务端，只要服务端实现了CORS接口，就可以跨源通信</p>
<p>实现CORS并不难，只需服务端做一些设置即可：</p>
<p><code>&lt;?phpheader(&quot;Access-Control-Allow-Origin:*&quot;); // 允许任何来源</code></p>
<h3 id="jQuery使用跨域"><a href="#jQuery使用跨域" class="headerlink" title="jQuery使用跨域"></a>jQuery使用跨域</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=<span class="string">"text"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ipt"</span>&gt;</span><br><span class="line">&lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"btn"</span>&gt;请求jsonp数据&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;ul class="list"&gt;&lt;/u</span>l&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">"../jquery-1.12.4.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(<span class="string">'.btn'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: <span class="string">'http://suggestion.baidu.com/su'</span>, <span class="comment">// 输入接口地址</span></span><br><span class="line">            type: <span class="string">'get'</span>, 		<span class="comment">//必须为get类型</span></span><br><span class="line">            data: <span class="string">'wd='</span> + $(<span class="string">'.ipt'</span>).val(),</span><br><span class="line">            cache: <span class="literal">false</span>,</span><br><span class="line">            dataType: <span class="string">'jsonp'</span>,  <span class="comment">//修改为jsonp格式</span></span><br><span class="line">            jsonp: <span class="string">'cb'</span>,        <span class="comment">//传入回调函数</span></span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">json</span>) </span>&#123;</span><br><span class="line">                $.each(json.s, <span class="function"><span class="keyword">function</span> (<span class="params">index, val</span>) </span>&#123;</span><br><span class="line">                    $(<span class="string">'.list'</span>).append(<span class="string">'&lt;li&gt;'</span> + val + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                alert(<span class="string">'请求失败'</span>)</span><br><span class="line">                <span class="built_in">console</span>.log(err.status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie与HTML5本地存储</title>
    <url>/2019/10/23/cookie%E4%B8%8EHTML5%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h2 id="cookie是什么"><a href="#cookie是什么" class="headerlink" title="cookie是什么"></a>cookie是什么</h2><blockquote>
<p>cookie是浏览器提供的一种机制，可以由JavaScript对其进行操作(设置、读取、删除)cookie是一种会话跟踪技术，是存储于访问者计算机中的一小块数据</p>
<p>会话：用户进入网站，开始浏览信息到关闭浏览器的过程，就称之为是一次会话会话跟踪技术：浏览器和服务器之间在进行多次请求间共享数据的过程，就称为会话跟踪技术</p>
</blockquote><a id="more"></a>
<p><strong>cookie的特性</strong>（服务端运行）</p>
<blockquote>
<ul>
<li>cookie可以实现跨页面全局变量</li>
<li>cookie可以跨越同域名下的多个网页，但不能跨域使用</li>
<li>cookie会随着HTTP请求发送给服务器</li>
<li>cookie会存储于访问者的计算机中</li>
<li>同一个网站中所有页面共享一套cookie</li>
<li>可以设置有效期限</li>
<li>存储空间为4KB左右</li>
<li><strong>cookie过期会自动消失</strong></li>
</ul>
</blockquote>
<p><strong>cookie的应用场景</strong></p>
<blockquote>
<ul>
<li>会话状态管理（如用户登录状态、购物车等）</li>
<li>个性化设置（保存用户设置的样式等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
</blockquote>
<p><strong>cookie的缺点</strong></p>
<blockquote>
<ol>
<li>cookie可能被禁用</li>
<li>cookie与浏览器相关，不能互相访问</li>
<li>cookie可能被用户删除</li>
<li>cookie安全性不够高</li>
<li>cookie会随着HTTP请求发送给服务器</li>
<li>cookie存储空间很小(只有4KB左右)</li>
<li>cookie操作麻烦，没有方便的API</li>
</ol>
</blockquote>
<hr>
<p><strong>操作cookie</strong></p>
<p>设置cookie:</p>
<p>如果要改变值，则需要重新赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"user=zhangsan"</span>;</span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"pass=123456"</span>;</span><br></pre></td></tr></table></figure>

<p>设置有效期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var d = new Date();</span><br><span class="line">d.setDate(d.getDate()+3); //按天数设置</span><br><span class="line">document.cookie=&quot;user3=xd; expires=&quot;+d;</span><br></pre></td></tr></table></figure>

<p>读取cookie</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var cookies = document.cookie;</span><br></pre></td></tr></table></figure>

<p>删除cookie:</p>
<p>可以将有效期设为一个已经过去的时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var d=new Date();</span><br><span class="line">d.setDate(d.getDate()-1);</span><br><span class="line">document.cookie=&quot;user1=xh; expires=&quot;+d;</span><br></pre></td></tr></table></figure>



<h2 id="HTML5本地存储"><a href="#HTML5本地存储" class="headerlink" title="HTML5本地存储"></a>HTML5本地存储</h2><blockquote>
<p>H5本地存储有 localStorage 与 sessionStorage 两种</p>
</blockquote>
<p><strong>优点：</strong></p>
<ul>
<li>更大的存储空间，有5MB左右</li>
<li>不会随HTTP请求发送给服务器</li>
<li>有方便的API操作</li>
<li>移动端普及高</li>
</ul>
<p><strong>操作：</strong></p>
<p> <strong>保存或设置数据</strong></p>
<p><code>localStorage.setItem(key , value)</code> </p>
<p>如果key已经存在，则覆盖key对应的value</p>
<p>如果不存在则添加key与value</p>
<p>  <strong>获取key对应的value</strong></p>
<p><code>localStorage.getItem(key)</code></p>
<p>  <strong>获取指定下标位置的key</strong></p>
<p><code>localStorage.key(index)</code></p>
<p><strong>获取数据条数（长度）</strong></p>
<p><code>localStorage.length</code></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">localStorage.clear() 将同域名下的所有数据都清空</span><br><span class="line"></span><br><span class="line">localStorage.removeItem(&apos;key&apos;) 删除某个键值对</span><br><span class="line"></span><br><span class="line">sessionStorage 为临时性保存数据，当页面关闭就会消失</span><br><span class="line">sessionStorage 不能跨页面访问，只局限在当前的标签页</span><br><span class="line">sessionStorage 各种操作与 localStorage 一样</span><br></pre></td></tr></table></figure>



<h2 id="JSON转换"><a href="#JSON转换" class="headerlink" title="JSON转换"></a>JSON转换</h2><blockquote>
<p>目前 JavaScript 使用非常多的 json 格式</p>
<p>可以使用 JSON.stringify() 将 json对象 转为 json字符串</p>
<p>然后把 json字符串 存储在 cookie 或 localStorage 里面</p>
<p>读取出来以后使用 JSON.parse() 将 json字符串 转为 json对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = &#123;<span class="string">"name1"</span>:<span class="string">"jack"</span>,<span class="string">"name2"</span>:<span class="string">"lily"</span>&#125;;</span><br><span class="line">localStorage.setItem(<span class="string">"user"</span>,<span class="built_in">JSON</span>.stringify(jsonObj)); <span class="comment">// 存储</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonObj = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">"user"</span>)); <span class="comment">// 读取</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>AJax的交互和异同</title>
    <url>/2019/10/23/aJax%E7%9A%84%E4%BA%A4%E4%BA%92%E5%8F%8A%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<blockquote>
<p>Ajax是什么？</p>
<p>Ajax是一种在无需加载整个网页的情况下，能够更新部分网页的技术（局部刷新）</p>
<p>通俗的来说，Ajax就是JS通过一个网址去加载数据，这个过程用户是不可见的，传统的网页（不使用Ajax）如果需要更新内容，必须重新加载整个网页</p>
</blockquote><a id="more"></a>
<h2 id="Ajax怎么使用"><a href="#Ajax怎么使用" class="headerlink" title="Ajax怎么使用"></a>Ajax怎么使用</h2><p><strong>ajax请求分4个步骤</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建XMLHttpRequest对象(数据交互对象)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);<span class="comment">//ie 5 6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.打开与服务器的链接</span></span><br><span class="line">xhr.open(<span class="string">'post'</span>,<span class="string">'xxx.php'</span>,<span class="literal">true</span>);<span class="comment">//解决缓存 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.发送请求</span></span><br><span class="line"><span class="comment">// xhr.send(null);//get请求</span></span><br><span class="line">xhr.send(<span class="string">'can='</span>+ele.value);<span class="comment">//post请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.等待服务的响应</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// console.log(xhr.readyState);//2 3 4</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;<span class="comment">//请求完成</span></span><br><span class="line">        <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;<span class="comment">//请求成功</span></span><br><span class="line">            <span class="keyword">var</span> json = <span class="built_in">JSON</span>.parse(xhr.responseText);<span class="comment">//转成json对象</span></span><br><span class="line">            con.innerHTML = <span class="string">''</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">'请求失败，'</span> + xhr.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="GET和POST之间的区别"><a href="#GET和POST之间的区别" class="headerlink" title="GET和POST之间的区别"></a>GET和POST之间的区别</h2><blockquote>
<ol>
<li>get参数通过url传递，post放在请求体（request  body）中；</li>
<li>get请求在url传递的参数有长度限制，而post没有；</li>
<li>get没有post安全，因为参数直接显示在url地址中，不能传递敏感数据</li>
<li>get请求浏览器会主动缓存，而post不会；</li>
<li>get请求参数会保存在浏览历史纪录，而post请求不会；</li>
</ol>
</blockquote>
<hr>
<h2 id="Ajax的函数封装"><a href="#Ajax的函数封装" class="headerlink" title="Ajax的函数封装"></a>Ajax的函数封装</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">option</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建XMLHttpRequest对象(数据交互对象)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);<span class="comment">//ie 5 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// data -&gt; 'a=123&amp;b=456'</span></span><br><span class="line">    <span class="keyword">if</span> (option.type == <span class="string">'get'</span> || option.type == <span class="string">'GET'</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.打开与服务器的链接</span></span><br><span class="line">        xhr.open(option.type,option.url + <span class="string">'?'</span>+ option.data + <span class="string">'&amp;_='</span>+<span class="keyword">new</span> <span class="built_in">Date</span>().getTime(),<span class="literal">true</span>);<span class="comment">//解决缓存</span></span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        xhr.send(<span class="literal">null</span>);<span class="comment">//get请求</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option.type == <span class="string">'post'</span> || option.type == <span class="string">'POST'</span>)&#123;</span><br><span class="line">        <span class="comment">// 2.打开与服务器的链接</span></span><br><span class="line">        xhr.open(option.type,option.url,<span class="literal">true</span>);<span class="comment">//解决缓存</span></span><br><span class="line">        <span class="comment">// 模拟表单form的post方式提交数据，在send之前设置</span></span><br><span class="line">        xhr.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        xhr.send(option.data);<span class="comment">//post请求</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">'目前只支持get和post请求方式!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.等待服务的响应</span></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// console.log(xhr.readyState);//2 3 4</span></span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;<span class="comment">//请求完成</span></span><br><span class="line">            <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;<span class="comment">//请求成功</span></span><br><span class="line">                option.success(xhr.responseText);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//请求失败</span></span><br><span class="line">                option.failed(xhr.status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用Ajax</span></span><br><span class="line">    ajax(&#123;</span><br><span class="line">        url: <span class="string">'./data/post.php'</span>,</span><br><span class="line">        type: <span class="string">'post'</span>,</span><br><span class="line">        data: <span class="string">'age='</span>+ ipt.value,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> json = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">            con.innerHTML = <span class="string">'姓名：'</span>+json.name;</span><br><span class="line">        &#125;,</span><br><span class="line">        failed: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">'请求失败'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="jQuery的Ajax调用"><a href="#jQuery的Ajax调用" class="headerlink" title="jQuery的Ajax调用"></a>jQuery的Ajax调用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">"study/data/get.php"</span>,</span><br><span class="line">    type: <span class="string">'get'</span>,</span><br><span class="line">    data: <span class="string">'age=28'</span>,</span><br><span class="line">    cache: <span class="literal">false</span>,       <span class="comment">//是否使用缓存</span></span><br><span class="line">    dataType: <span class="string">'json'</span>,   <span class="comment">//转换成json或者text格式</span></span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        $(<span class="string">'.con'</span>).text(data.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    $.<span class="keyword">get</span>('study/data/<span class="keyword">get</span>.php', 'age=18', function (json) &#123;</span><br><span class="line">        $(<span class="string">'.con'</span>).text(json.name)</span><br><span class="line">    &#125;, <span class="string">'json'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>笔记</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown语法教程</title>
    <url>/2019/10/21/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>MarkDown是一种纯文本格式的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>下面让我们一起来快速学习一下MarkDown的语法吧</p>
</blockquote><h3 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h3><p>一般是在标题文字前面加上#来表示</p><p>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p><a id="more"></a>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h3><ul>
<li><strong>加粗</strong></li>
</ul>
<p>要加粗的文字左右分别用两个*号包起来</p>
<ul>
<li><strong>斜体</strong></li>
</ul>
<p>要倾斜的文字左右分别用一个*号包起来</p>
<ul>
<li><strong>斜体加粗</strong></li>
</ul>
<p>要倾斜和加粗的文字左右分别用三个*号包起来</p>
<ul>
<li><strong>删除线</strong></li>
</ul>
<p>要加删除线的文字左右分别用两个~~号包起来</p>
<p>代码示例：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**这是加粗的文字**</span></span><br><span class="line"><span class="emphasis">*这是倾斜的文字*</span></span><br><span class="line"><span class="strong">***这是斜体加粗的文字**</span>*</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h3><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;，可以加任意个&gt;</p>
<p>示例：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h3><p>三个或者三个以上的 - 或者 * 都可以。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line"><span class="emphasis">***</span></span><br><span class="line"><span class="strong">*****</span></span><br></pre></td></tr></table></figure>

<p>四行代码的效果都是一样的。</p>
<hr>
<h3 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片alt</span>](<span class="link">"图片地址" "图片title"</span>)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h3><p>示例</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">超链接名</span>](<span class="link">超链接地址 "超链接title"</span>)</span><br><span class="line">title可以不加，看个人需求</span><br><span class="line"></span><br><span class="line">[<span class="string">百度</span>](<span class="link">https://baidu.com</span>)</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h3><ul>
<li><strong>无序列表</strong></li>
</ul>
<p>语法：</p>
<p>无序列表用 - + * 任何一种都可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>有序列表</strong></li>
</ul>
<p>数字加点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.列表内容</span><br><span class="line">2.列表内容</span><br><span class="line">3.列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>列表嵌套</strong></li>
</ul>
<p><strong>第二级列表按下tab键缩进</strong></p>
<ul>
<li>一级列表<ul>
<li>二级列表</li>
</ul>
</li>
</ul>
<hr>
<h3 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h3><p>语法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 姓名 | 技能 | 排行 |</span><br><span class="line">| ---- | :--: | ---: |</span><br><span class="line">| 刘备 |  哭  | 大哥 |</span><br><span class="line">| 关羽 |  打  | 二哥 |</span><br><span class="line">| 张飞 |  骂  | 三弟 |</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h3><p>语法</p>
<p>单行代码：代码之间分别用一个反引号包起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`代码内容`</span><br></pre></td></tr></table></figure>

<p>代码块：使用三个反引号回车即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(```)</span><br><span class="line">	代码</span><br><span class="line">	代码</span><br><span class="line">	代码</span><br><span class="line">	</span><br><span class="line">注：这里为了三个反引号不被浏览器转义加上了括号，实际上不需要添加</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>常用</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建博客</title>
    <url>/2019/10/19/Hexo%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<blockquote>
<p>使用Hexo快速搭建一个自己的专属博客</p>
<p>搭建要求：node.js，git bash, github仓库</p>
<p>很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行；</p>
</blockquote><a id="more"></a>
<p><strong>安装之前的准备</strong></p>
<blockquote>
<ul>
<li><p>有一个github账号，这是必要的</p>
</li>
<li><p>安装了node.js  npm  并且了解基本终端指令</p>
</li>
<li><p>最好有一个git bash</p>
</li>
</ul>
</blockquote>
<p><strong>开始安装hexo</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure>

<p><strong>初始化</strong></p>
<p>在电脑任意地方新建一个文件夹，用于存放博客文件</p>
<p>找到当前文件夹的地址进行初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>

<p><strong>生成文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"新文档"</span></span><br></pre></td></tr></table></figure>

<p><strong>生成静态文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p><strong>发送到本地端口服务器</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>此时已经生成了本地端口号，默认都是localhost:4000</p>
<p>输入端口，成功后会出现一个默认的博客页面</p>
<p><strong>部署网站</strong></p>
<p>将博客部署到github上面，以后就可以通过github域名查看博客</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p><strong>清除缓存和已生成的静态文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>

<p><strong>ERROR Deployer not found: git 解决方法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
