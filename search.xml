<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>模块化编程</title>
    <url>/2019/10/28/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="ES6-module"><a href="#ES6-module" class="headerlink" title="ES6 module"></a>ES6 module</h2><blockquote>
<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD  两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
</blockquote><a id="more"></a>
<p><strong>设置浏览器启用es6语法功能：（Chrome 61+，Firefox 54+）</strong></p>
<blockquote>
<ol>
<li><p>在浏览器的url中输入：<a href="chrome://flags/" target="_blank" rel="noopener">chrome://flags/</a></p>
</li>
<li><p>搜索 JavaScript 关键字</p>
</li>
<li><p>设置选项 Experimental JavaScript 为 Enable</p>
</li>
<li><p>重启浏览器后生效</p>
</li>
</ol>
</blockquote>
<p><strong>注意事项</strong></p>
<blockquote>
<ul>
<li><p>script 标签里面要加 type=”module”, 这样浏览器才会把相关的代码当作ES6的module 来对待</p>
</li>
<li><p>不能写“裸”路径，即使是同一层级下面的文件，也要加上 ‘./name.js’</p>
</li>
<li><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”。</p>
</li>
<li><p>ES6 模块功能主要由两个命令构成：export 和 import。</p>
</li>
<li><p>export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
</li>
<li><p>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。</p>
</li>
</ul>
</blockquote>
<h3 id="export-关键字"><a href="#export-关键字" class="headerlink" title="export 关键字"></a><strong>export 关键字</strong></h3><p>如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userName = <span class="string">'xiaoming'</span>;</span><br><span class="line"><span class="keyword">var</span> userSex = <span class="string">'男'</span>;</span><br><span class="line"><span class="keyword">var</span> userAge = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; userName, userSex, userAge &#125;;</span><br></pre></td></tr></table></figure>

<p>export命令除了输出变量，还可以输出对象、函数或类（class）。</p>
<p><code>export function sum(x, y) { return x + y;};</code></p>
<p>上面代码对外输出一个函数sum</p>
<p>通常情况下，export输出的变量就是本来的名字，但是可以使用<strong>as关键字</strong>重命名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  f1 <span class="keyword">as</span> test1,</span><br><span class="line">  f2 <span class="keyword">as</span> test2,</span><br><span class="line">  f2 <span class="keyword">as</span> test3</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码使用as关键字，重命名了函数f1和f2的对外接口。重命名后，f2可以用不同的名字输出两次。</p>
<p><strong>正确的写法</strong></p>
<ul>
<li><p><code>export var m = 1;</code></p>
</li>
<li><p><code>var m = 1;  export {m};</code></p>
</li>
<li><p><code>var n = 1;    export {n as m};</code></p>
</li>
<li><p><code>export function f() {};</code></p>
</li>
<li><p><code>function f() {}export {f};</code></p>
</li>
</ul>
<h3 id="import-关键字"><a href="#import-关键字" class="headerlink" title="import 关键字"></a>import 关键字</h3><p>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; userName, userSex, userAge &#125; <span class="keyword">from</span> <span class="string">'./module1.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(userName);</span><br><span class="line"><span class="built_in">console</span>.log(userSex);</span><br><span class="line"><span class="built_in">console</span>.log(userAge);</span><br></pre></td></tr></table></figure>

<p>如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。</p>
<p><code>import { userName as xm } from &#39;./module1.js&#39;;</code></p>
<p>import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。如果a是一个对象，改写a的属性是允许的。</p>
<p><code>import {a} from &#39;./xxx.js&#39;        a.foo = &#39;hello&#39;; // 合法操作</code></p>
<p><strong>import命令具有提升效果，会提升到整个模块的头部，首先执行。</strong></p>
<p>除了指定加载某些输出值，还可以使用整体加载，即用 * 指定一个对象，所有输出值都加载在这个对象上面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> obj <span class="keyword">from</span> <span class="string">'./module1.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.userName);</span><br><span class="line"><span class="built_in">console</span>.log(obj.userSex);</span><br><span class="line"><span class="built_in">console</span>.log(obj.userAge);</span><br></pre></td></tr></table></figure>

<h3 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h3><p>为了给用户提供方便，用export default命令，为模块指定默认输出。</p>
<p>默认输出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 输出</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">'./test.js'</span>; <span class="comment">// 输入</span></span><br></pre></td></tr></table></figure>

<p>正常输出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 输出</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">import</span> &#123; test &#125; <span class="keyword">from</span> <span class="string">'./test.js'</span>; <span class="comment">// 输入</span></span><br></pre></td></tr></table></figure>

<p>使用export default时，对应的import语句不需要使用大括号；</p>
<p>不使用export default时，对应的import语句需要使用大括号。</p>
<p><strong>注意：</strong></p>
<p>一个模块只能有一个默认输出，因此export default命令只能使用一次。</p>
<p>因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<h2 id="浏览器加载规则"><a href="#浏览器加载规则" class="headerlink" title="浏览器加载规则"></a>浏览器加载规则</h2><blockquote>
<p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到script&gt;标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。</p>
</blockquote>
<p><strong>浏览器两种异步加载的语法</strong></p>
<p><code>&lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt;</code></p>
<p><code>&lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt;</code></p>
<p>上面代码中，script&gt;标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p>
<p><strong>defer与async的区别</strong></p>
<p>defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；</p>
<p>async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染</p>
<p><strong>defer是“渲染完再执行”，async是“下载完就执行”。</strong></p>
<p>如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</p>
<p>浏览器加载 ES6 模块，也使用script&gt;标签，但是要加入type=”module”属性。</p>
<p>浏览器对于带有type=”module”的script&gt;，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了script&gt;标签的defer属性。</p>
<p><code>&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot; defer&gt;&lt;/script&gt;</code></p>
<h2 id="RequireJs"><a href="#RequireJs" class="headerlink" title="RequireJs"></a>RequireJs</h2><p><strong>什么是RequireJs</strong></p>
<blockquote>
<p>RequireJS是一个非常小巧的JavaScript模块载入框架，是AMD规范最好的实现者之一。</p>
<p>AMD即Asynchronous Module Definition（异步模块定义）。</p>
<p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。</p>
<p>CMD即Common Moudle Definition（通用模块定义）。</p>
<p>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</p>
</blockquote>
<p><strong>AMD和CMD相同点：</strong></p>
<blockquote>
<ul>
<li>都是异步加载模块；</li>
<li>都实现了浏览器端模块化开发的目的；</li>
<li>都倡导模块化开发理念，使前端模块化开发变得简单自然；</li>
<li>解决前端开发过程中的两大问题：<ol>
<li>文件之间的依赖问题；</li>
<li>浏览器加载多个JS文件时页面失去响应的时间过长。</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>AMD和CMD不同点：</strong></p>
<blockquote>
<ol>
<li>官方推荐的写法不同，AMD推崇依赖前置，CMD推崇依赖就近；</li>
<li>模块的执行时机不同，AMD是提前执行，CMD是延迟执行；</li>
<li>api的设计不同，AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。</li>
</ol>
</blockquote>
<p><strong>“一个模块就是一个文件”</strong></p>
<p><strong>require 用来加载依赖模块，并执行加载完后的回调函数</strong></p>
<p><code>require([&#39;moduleA&#39;, &#39;moduleB&#39;], function (a, b){ });</code></p>
<p>第一个参数是依赖模块列表，第二个参数是一个callback函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局配置</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">'js/lib'</span>,</span><br><span class="line">    paths : &#123;</span><br><span class="line">        <span class="string">"jquery"</span> : [<span class="string">"http://libs.baidu.com/jquery/2.0.3/jquery"</span>,<span class="string">"jquery-2.1.4.min"</span>],</span><br><span class="line">        <span class="string">"mytask"</span> : <span class="string">"myTask"</span>   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">require</span>([<span class="string">"jquery"</span>,<span class="string">"mytask"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$, mytask</span>)</span>&#123;</span><br><span class="line">    $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       mytask(<span class="string">"load finished"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>require.config</strong>是用来配置模块加载位置，简单点说就是<strong>引入模块并起一个别名</strong></p>
<p>配置完成还要记得在html中设置<strong>入口文件</strong></p>
<p><code>&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;</code></p>
<p><strong>define 用来定义一个模块</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(&#123;</span><br><span class="line">　 <span class="comment">// ...</span></span><br><span class="line">    key: value</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"> </span>)</span>&#123;</span><br><span class="line">　 <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">define([<span class="string">'依赖的模块路径'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">依赖模块名称</span>)</span>&#123;</span><br><span class="line">　<span class="comment">// ...</span></span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　<span class="comment">// ...</span></span><br><span class="line">　&#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">define(<span class="string">'模块名称'</span>, [<span class="string">'依赖的模块路径'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">依赖模块名称</span>)</span>&#123;</span><br><span class="line">　<span class="comment">// ...</span></span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　<span class="comment">// ...</span></span><br><span class="line">　&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2019/10/24/Promise%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote>
<p>Promise 是ES6对异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理更强大。</p>
<p>Promise 简单说就是一个容器，里面保存着一个尚未完成且预计在未来完成的异步操作。</p>
<p>Promise 是一个构造函数，用来创建一个Promise对象。</p>
<p>有了Promise对象，就可以将<strong>异步操作以同步操作的流程表达出来</strong>，避免了层层嵌套的回调函数。</p>
</blockquote><a id="more"></a>
<h3 id="Promise对象代表一个异步操作，有三种状态："><a href="#Promise对象代表一个异步操作，有三种状态：" class="headerlink" title="Promise对象代表一个异步操作，有三种状态："></a>Promise对象代表一个异步操作，有三种状态：</h3><ul>
<li>pending（进行中）</li>
<li>fulfilled（已成功）</li>
<li>rejected（已失败）</li>
</ul>
<h3 id="Promise-对象的状态改变有两种："><a href="#Promise-对象的状态改变有两种：" class="headerlink" title="Promise 对象的状态改变有两种："></a>Promise 对象的状态改变有两种：</h3><p>从 pending 变为 fulfilled</p>
<p>从 pending 变为 rejected</p>
<hr>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。</p>
<p>resolve 和 reject 是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>resolve</strong> 函数的作用是，将Promise对象的状态从“进行中”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。</p>
<p><strong>reject</strong> 函数的作用是，将Promise对象的状态从“进行中”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<hr>
<h3 id="then和catch"><a href="#then和catch" class="headerlink" title="then和catch"></a>then和catch</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//成功执行的函数（resolve）</span></span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">    </span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rej</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//失败执行的函数（reject）</span></span><br><span class="line">    <span class="built_in">console</span>.log(rej)</span><br><span class="line">    </span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">    <span class="comment">//捕获报错信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>then</strong>有两个参数，一个是成功后的回调函数，另一个是失败后的回调函数</p>
<p><strong>catch</strong>是一个用于指定发生错误的回调函数，将报错信息捕获</p>
<h3 id="使用Promise解决定时器嵌套问题"><a href="#使用Promise解决定时器嵌套问题" class="headerlink" title="使用Promise解决定时器嵌套问题"></a>使用Promise解决定时器嵌套问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装一个Promise的定时器函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPromise</span>(<span class="params">msg, time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(msg);</span><br><span class="line">                resolve();</span><br><span class="line">            &#125;, time)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//利用getPromise函数同步执行</span></span><br><span class="line"><span class="comment">//结果为： 一 二 三 完成</span></span><br><span class="line">    getPromise(<span class="string">'第一个任务'</span>, <span class="number">1000</span>)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getPromise(<span class="string">'第二个任务'</span>, <span class="number">2000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getPromise(<span class="string">'第三个任务'</span>, <span class="number">3000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getPromise(<span class="string">'完成'</span>, <span class="number">4000</span>)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域</title>
    <url>/2019/10/23/%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="Ajax跨域"><a href="#Ajax跨域" class="headerlink" title="Ajax跨域"></a>Ajax跨域</h2><blockquote>
<p>由于浏览器的同源策略，禁止ajax从一个域名请求另外一个域名上的数据。</p>
<p>浏览器的同源策略，是对JavaScript实施的安全限制</p>
</blockquote><p><strong>所谓的同源是指，域名，协议，端口都相同</strong></p><p><a href="http://image.baidu.com/search/detail?ct=503316480&z=undefined#header" target="_blank" rel="noopener">http://image.baidu.com:80/search/detail?ct=503316480&amp;z=undefined#header</a></p><a id="more"></a>


<p>URL构成：http —- 超文本传输协议</p>
<p><a href="http://image.baidu.com/" target="_blank" rel="noopener">image.baidu.com</a> —- 域名</p>
<p>80 —- 端口</p>
<p>/search/detail —- 资源目录</p>
<p>ct=503316480&amp;z=undefined —- 发送到服务器的数据</p>
<p>#header —- 锚点</p>
<h3 id="常见的跨域解决方案"><a href="#常见的跨域解决方案" class="headerlink" title="常见的跨域解决方案"></a>常见的跨域解决方案</h3><ol>
<li><strong>通过服务端语言代理请求。</strong></li>
</ol>
<p>如PHP，服务端语言php是没有跨域限制的。 让服务器去别的网站获取内容然后返回页面。</p>
<ol start="2">
<li><p><strong>jsonp跨域</strong></p>
<ul>
<li><p>jsonp跨域就是利用script标签的跨域能力请求资源</p>
</li>
<li><p>既然叫jsonp，显然目的还是json，而且是跨域获取</p>
</li>
<li><p><strong>利用js创建一个script标签，把json的url赋给script的scr属性，把这个script插入到页面里，让浏览器去跨域获取资源</strong></p>
</li>
<li><p>callback是页面存在的回调方法，参数就是想得到的json</p>
</li>
<li><p>回调方法要遵从服务端的约定一般是用 callback 或者 cb</p>
</li>
<li><p><strong>jsonp只针对get请求</strong></p>
</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">OScript = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);<span class="comment">//创建script标签 </span></span><br><span class="line">OScript.src = <span class="string">'http://suggestion.baidu.com/su?wd='</span> + <span class="keyword">this</span>.value + <span class="string">'&amp;cb=myCallback'</span>;</span><br><span class="line"><span class="comment">//把数据地址赋值给src</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(OScript);<span class="comment">//添加到页面</span></span><br></pre></td></tr></table></figure>



<ol start="3">
<li><strong>CORS 跨域资源共享(xhr2)</strong></li>
</ol>
<p>实现CORS通信的关键是服务端，只要服务端实现了CORS接口，就可以跨源通信</p>
<p>实现CORS并不难，只需服务端做一些设置即可：</p>
<p><code>&lt;?phpheader(&quot;Access-Control-Allow-Origin:*&quot;); // 允许任何来源</code></p>
<h3 id="jQuery使用跨域"><a href="#jQuery使用跨域" class="headerlink" title="jQuery使用跨域"></a>jQuery使用跨域</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=<span class="string">"text"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ipt"</span>&gt;</span><br><span class="line">&lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"btn"</span>&gt;请求jsonp数据&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;ul class="list"&gt;&lt;/u</span>l&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">"../jquery-1.12.4.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(<span class="string">'.btn'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: <span class="string">'http://suggestion.baidu.com/su'</span>, <span class="comment">// 输入接口地址</span></span><br><span class="line">            type: <span class="string">'get'</span>, 		<span class="comment">//必须为get类型</span></span><br><span class="line">            data: <span class="string">'wd='</span> + $(<span class="string">'.ipt'</span>).val(),</span><br><span class="line">            cache: <span class="literal">false</span>,</span><br><span class="line">            dataType: <span class="string">'jsonp'</span>,  <span class="comment">//修改为jsonp格式</span></span><br><span class="line">            jsonp: <span class="string">'cb'</span>,        <span class="comment">//传入回调函数</span></span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">json</span>) </span>&#123;</span><br><span class="line">                $.each(json.s, <span class="function"><span class="keyword">function</span> (<span class="params">index, val</span>) </span>&#123;</span><br><span class="line">                    $(<span class="string">'.list'</span>).append(<span class="string">'&lt;li&gt;'</span> + val + <span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                alert(<span class="string">'请求失败'</span>)</span><br><span class="line">                <span class="built_in">console</span>.log(err.status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie与HTML5本地存储</title>
    <url>/2019/10/23/cookie%E4%B8%8EHTML5%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h2 id="cookie是什么"><a href="#cookie是什么" class="headerlink" title="cookie是什么"></a>cookie是什么</h2><blockquote>
<p>cookie是浏览器提供的一种机制，可以由JavaScript对其进行操作(设置、读取、删除)cookie是一种会话跟踪技术，是存储于访问者计算机中的一小块数据</p>
<p>会话：用户进入网站，开始浏览信息到关闭浏览器的过程，就称之为是一次会话会话跟踪技术：浏览器和服务器之间在进行多次请求间共享数据的过程，就称为会话跟踪技术</p>
</blockquote><a id="more"></a>
<p><strong>cookie的特性</strong>（服务端运行）</p>
<blockquote>
<ul>
<li>cookie可以实现跨页面全局变量</li>
<li>cookie可以跨越同域名下的多个网页，但不能跨域使用</li>
<li>cookie会随着HTTP请求发送给服务器</li>
<li>cookie会存储于访问者的计算机中</li>
<li>同一个网站中所有页面共享一套cookie</li>
<li>可以设置有效期限</li>
<li>存储空间为4KB左右</li>
<li><strong>cookie过期会自动消失</strong></li>
</ul>
</blockquote>
<p><strong>cookie的应用场景</strong></p>
<blockquote>
<ul>
<li>会话状态管理（如用户登录状态、购物车等）</li>
<li>个性化设置（保存用户设置的样式等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
</blockquote>
<p><strong>cookie的缺点</strong></p>
<blockquote>
<ol>
<li>cookie可能被禁用</li>
<li>cookie与浏览器相关，不能互相访问</li>
<li>cookie可能被用户删除</li>
<li>cookie安全性不够高</li>
<li>cookie会随着HTTP请求发送给服务器</li>
<li>cookie存储空间很小(只有4KB左右)</li>
<li>cookie操作麻烦，没有方便的API</li>
</ol>
</blockquote>
<hr>
<p><strong>操作cookie</strong></p>
<p>设置cookie:</p>
<p>如果要改变值，则需要重新赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"user=zhangsan"</span>;</span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"pass=123456"</span>;</span><br></pre></td></tr></table></figure>

<p>设置有效期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var d = new Date();</span><br><span class="line">d.setDate(d.getDate()+3); //按天数设置</span><br><span class="line">document.cookie=&quot;user3=xd; expires=&quot;+d;</span><br></pre></td></tr></table></figure>

<p>读取cookie</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var cookies = document.cookie;</span><br></pre></td></tr></table></figure>

<p>删除cookie:</p>
<p>可以将有效期设为一个已经过去的时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var d=new Date();</span><br><span class="line">d.setDate(d.getDate()-1);</span><br><span class="line">document.cookie=&quot;user1=xh; expires=&quot;+d;</span><br></pre></td></tr></table></figure>



<h2 id="HTML5本地存储"><a href="#HTML5本地存储" class="headerlink" title="HTML5本地存储"></a>HTML5本地存储</h2><blockquote>
<p>H5本地存储有 localStorage 与 sessionStorage 两种</p>
</blockquote>
<p><strong>优点：</strong></p>
<ul>
<li>更大的存储空间，有5MB左右</li>
<li>不会随HTTP请求发送给服务器</li>
<li>有方便的API操作</li>
<li>移动端普及高</li>
</ul>
<p><strong>操作：</strong></p>
<p> <strong>保存或设置数据</strong></p>
<p><code>localStorage.setItem(key , value)</code> </p>
<p>如果key已经存在，则覆盖key对应的value</p>
<p>如果不存在则添加key与value</p>
<p>  <strong>获取key对应的value</strong></p>
<p><code>localStorage.getItem(key)</code></p>
<p>  <strong>获取指定下标位置的key</strong></p>
<p><code>localStorage.key(index)</code></p>
<p><strong>获取数据条数（长度）</strong></p>
<p><code>localStorage.length</code></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">localStorage.clear() 将同域名下的所有数据都清空</span><br><span class="line"></span><br><span class="line">localStorage.removeItem(&apos;key&apos;) 删除某个键值对</span><br><span class="line"></span><br><span class="line">sessionStorage 为临时性保存数据，当页面关闭就会消失</span><br><span class="line">sessionStorage 不能跨页面访问，只局限在当前的标签页</span><br><span class="line">sessionStorage 各种操作与 localStorage 一样</span><br></pre></td></tr></table></figure>



<h2 id="JSON转换"><a href="#JSON转换" class="headerlink" title="JSON转换"></a>JSON转换</h2><blockquote>
<p>目前 JavaScript 使用非常多的 json 格式</p>
<p>可以使用 JSON.stringify() 将 json对象 转为 json字符串</p>
<p>然后把 json字符串 存储在 cookie 或 localStorage 里面</p>
<p>读取出来以后使用 JSON.parse() 将 json字符串 转为 json对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = &#123;<span class="string">"name1"</span>:<span class="string">"jack"</span>,<span class="string">"name2"</span>:<span class="string">"lily"</span>&#125;;</span><br><span class="line">localStorage.setItem(<span class="string">"user"</span>,<span class="built_in">JSON</span>.stringify(jsonObj)); <span class="comment">// 存储</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonObj = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">"user"</span>)); <span class="comment">// 读取</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>AJax的交互和异同</title>
    <url>/2019/10/23/aJax%E7%9A%84%E4%BA%A4%E4%BA%92%E5%8F%8A%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<blockquote>
<p>Ajax是什么？</p>
<p>Ajax是一种在无需加载整个网页的情况下，能够更新部分网页的技术（局部刷新）</p>
<p>通俗的来说，Ajax就是JS通过一个网址去加载数据，这个过程用户是不可见的，传统的网页（不使用Ajax）如果需要更新内容，必须重新加载整个网页</p>
</blockquote><a id="more"></a>
<h2 id="Ajax怎么使用"><a href="#Ajax怎么使用" class="headerlink" title="Ajax怎么使用"></a>Ajax怎么使用</h2><p><strong>ajax请求分4个步骤</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建XMLHttpRequest对象(数据交互对象)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);<span class="comment">//ie 5 6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.打开与服务器的链接</span></span><br><span class="line">xhr.open(<span class="string">'post'</span>,<span class="string">'xxx.php'</span>,<span class="literal">true</span>);<span class="comment">//解决缓存 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.发送请求</span></span><br><span class="line"><span class="comment">// xhr.send(null);//get请求</span></span><br><span class="line">xhr.send(<span class="string">'can='</span>+ele.value);<span class="comment">//post请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.等待服务的响应</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// console.log(xhr.readyState);//2 3 4</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;<span class="comment">//请求完成</span></span><br><span class="line">        <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;<span class="comment">//请求成功</span></span><br><span class="line">            <span class="keyword">var</span> json = <span class="built_in">JSON</span>.parse(xhr.responseText);<span class="comment">//转成json对象</span></span><br><span class="line">            con.innerHTML = <span class="string">''</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">'请求失败，'</span> + xhr.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="GET和POST之间的区别"><a href="#GET和POST之间的区别" class="headerlink" title="GET和POST之间的区别"></a>GET和POST之间的区别</h2><blockquote>
<ol>
<li>get参数通过url传递，post放在请求体（request  body）中；</li>
<li>get请求在url传递的参数有长度限制，而post没有；</li>
<li>get没有post安全，因为参数直接显示在url地址中，不能传递敏感数据</li>
<li>get请求浏览器会主动缓存，而post不会；</li>
<li>get请求参数会保存在浏览历史纪录，而post请求不会；</li>
</ol>
</blockquote>
<hr>
<h2 id="Ajax的函数封装"><a href="#Ajax的函数封装" class="headerlink" title="Ajax的函数封装"></a>Ajax的函数封装</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">option</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建XMLHttpRequest对象(数据交互对象)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);<span class="comment">//ie 5 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// data -&gt; 'a=123&amp;b=456'</span></span><br><span class="line">    <span class="keyword">if</span> (option.type == <span class="string">'get'</span> || option.type == <span class="string">'GET'</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.打开与服务器的链接</span></span><br><span class="line">        xhr.open(option.type,option.url + <span class="string">'?'</span>+ option.data + <span class="string">'&amp;_='</span>+<span class="keyword">new</span> <span class="built_in">Date</span>().getTime(),<span class="literal">true</span>);<span class="comment">//解决缓存</span></span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        xhr.send(<span class="literal">null</span>);<span class="comment">//get请求</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option.type == <span class="string">'post'</span> || option.type == <span class="string">'POST'</span>)&#123;</span><br><span class="line">        <span class="comment">// 2.打开与服务器的链接</span></span><br><span class="line">        xhr.open(option.type,option.url,<span class="literal">true</span>);<span class="comment">//解决缓存</span></span><br><span class="line">        <span class="comment">// 模拟表单form的post方式提交数据，在send之前设置</span></span><br><span class="line">        xhr.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        xhr.send(option.data);<span class="comment">//post请求</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">'目前只支持get和post请求方式!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.等待服务的响应</span></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// console.log(xhr.readyState);//2 3 4</span></span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;<span class="comment">//请求完成</span></span><br><span class="line">            <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;<span class="comment">//请求成功</span></span><br><span class="line">                option.success(xhr.responseText);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//请求失败</span></span><br><span class="line">                option.failed(xhr.status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用Ajax</span></span><br><span class="line">    ajax(&#123;</span><br><span class="line">        url: <span class="string">'./data/post.php'</span>,</span><br><span class="line">        type: <span class="string">'post'</span>,</span><br><span class="line">        data: <span class="string">'age='</span>+ ipt.value,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> json = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">            con.innerHTML = <span class="string">'姓名：'</span>+json.name;</span><br><span class="line">        &#125;,</span><br><span class="line">        failed: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">'请求失败'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="jQuery的Ajax调用"><a href="#jQuery的Ajax调用" class="headerlink" title="jQuery的Ajax调用"></a>jQuery的Ajax调用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">"study/data/get.php"</span>,</span><br><span class="line">    type: <span class="string">'get'</span>,</span><br><span class="line">    data: <span class="string">'age=28'</span>,</span><br><span class="line">    cache: <span class="literal">false</span>,       <span class="comment">//是否使用缓存</span></span><br><span class="line">    dataType: <span class="string">'json'</span>,   <span class="comment">//转换成json或者text格式</span></span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        $(<span class="string">'.con'</span>).text(data.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    $.<span class="keyword">get</span>('study/data/<span class="keyword">get</span>.php', 'age=18', function (json) &#123;</span><br><span class="line">        $(<span class="string">'.con'</span>).text(json.name)</span><br><span class="line">    &#125;, <span class="string">'json'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown语法教程</title>
    <url>/2019/10/21/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>MarkDown是一种纯文本格式的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>下面让我们一起来快速学习一下MarkDown的语法吧</p>
</blockquote><h3 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h3><p>一般是在标题文字前面加上#来表示</p><p>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p><a id="more"></a>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h3><ul>
<li><strong>加粗</strong></li>
</ul>
<p>要加粗的文字左右分别用两个*号包起来</p>
<ul>
<li><strong>斜体</strong></li>
</ul>
<p>要倾斜的文字左右分别用一个*号包起来</p>
<ul>
<li><strong>斜体加粗</strong></li>
</ul>
<p>要倾斜和加粗的文字左右分别用三个*号包起来</p>
<ul>
<li><strong>删除线</strong></li>
</ul>
<p>要加删除线的文字左右分别用两个~~号包起来</p>
<p>代码示例：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**这是加粗的文字**</span></span><br><span class="line"><span class="emphasis">*这是倾斜的文字*</span></span><br><span class="line"><span class="strong">***这是斜体加粗的文字**</span>*</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h3><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;，可以加任意个&gt;</p>
<p>示例：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h3><p>三个或者三个以上的 - 或者 * 都可以。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line"><span class="emphasis">***</span></span><br><span class="line"><span class="strong">*****</span></span><br></pre></td></tr></table></figure>

<p>四行代码的效果都是一样的。</p>
<hr>
<h3 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片alt</span>](<span class="link">"图片地址" "图片title"</span>)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h3><p>示例</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">超链接名</span>](<span class="link">超链接地址 "超链接title"</span>)</span><br><span class="line">title可以不加，看个人需求</span><br><span class="line"></span><br><span class="line">[<span class="string">百度</span>](<span class="link">https://baidu.com</span>)</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h3><ul>
<li><strong>无序列表</strong></li>
</ul>
<p>语法：</p>
<p>无序列表用 - + * 任何一种都可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>有序列表</strong></li>
</ul>
<p>数字加点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.列表内容</span><br><span class="line">2.列表内容</span><br><span class="line">3.列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>列表嵌套</strong></li>
</ul>
<p><strong>第二级列表按下tab键缩进</strong></p>
<ul>
<li>一级列表<ul>
<li>二级列表</li>
</ul>
</li>
</ul>
<hr>
<h3 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h3><p>语法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 姓名 | 技能 | 排行 |</span><br><span class="line">| ---- | :--: | ---: |</span><br><span class="line">| 刘备 |  哭  | 大哥 |</span><br><span class="line">| 关羽 |  打  | 二哥 |</span><br><span class="line">| 张飞 |  骂  | 三弟 |</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h3><p>语法</p>
<p>单行代码：代码之间分别用一个反引号包起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`代码内容`</span><br></pre></td></tr></table></figure>

<p>代码块：使用三个反引号回车即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(```)</span><br><span class="line">	代码</span><br><span class="line">	代码</span><br><span class="line">	代码</span><br><span class="line">	</span><br><span class="line">注：这里为了三个反引号不被浏览器转义加上了括号，实际上不需要添加</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>常用</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建博客</title>
    <url>/2019/10/19/Hexo%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<blockquote>
<p>使用Hexo快速搭建一个自己的专属博客</p>
<p>搭建要求：node.js，git bash, github仓库</p>
<p>很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行；</p>
</blockquote><a id="more"></a>
<p><strong>安装之前的准备</strong></p>
<blockquote>
<ul>
<li><p>有一个github账号，这是必要的</p>
</li>
<li><p>安装了node.js  npm  并且了解基本终端指令</p>
</li>
<li><p>最好有一个git bash</p>
</li>
</ul>
</blockquote>
<p><strong>开始安装hexo</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure>

<p><strong>初始化</strong></p>
<p>在电脑任意地方新建一个文件夹，用于存放博客文件</p>
<p>找到当前文件夹的地址进行初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>

<p><strong>生成文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"新文档"</span></span><br></pre></td></tr></table></figure>

<p><strong>生成静态文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p><strong>发送到本地端口服务器</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>此时已经生成了本地端口号，默认都是localhost:4000</p>
<p>输入端口，成功后会出现一个默认的博客页面</p>
<p><strong>部署网站</strong></p>
<p>将博客部署到github上面，以后就可以通过github域名查看博客</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p><strong>清除缓存和已生成的静态文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>

<p><strong>ERROR Deployer not found: git 解决方法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>语法</tag>
      </tags>
  </entry>
</search>
