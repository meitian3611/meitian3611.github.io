---
title: 模块化编程
date: 2019-10-28 21:17:12
tags: 
	- 笔记
	- 知识点
categories: web前端
---

## ES6 module

> 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD  两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。

**设置浏览器启用es6语法功能：（Chrome 61+，Firefox 54+）**

> 1. 在浏览器的url中输入：[chrome://flags/](chrome://flags/)
>
> 2. 搜索 JavaScript 关键字
>
> 3. 设置选项 Experimental JavaScript 为 Enable
>
> 4. 重启浏览器后生效

**注意事项**

> - script 标签里面要加 type="module", 这样浏览器才会把相关的代码当作ES6的module 来对待
>
> - 不能写“裸”路径，即使是同一层级下面的文件，也要加上 './name.js'
>
> - ES6 的模块自动采用严格模式，不管你有没有在模块头部加上"use strict"。
>
> - ES6 模块功能主要由两个命令构成：export 和 import。
>
> - export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。
>
> - 一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。

### **export 关键字**

如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。

```javascript
var userName = 'xiaoming';
var userSex = '男';
var userAge = 27;
export { userName, userSex, userAge };
```

export命令除了输出变量，还可以输出对象、函数或类（class）。

`export function sum(x, y) { return x + y;}; `

上面代码对外输出一个函数sum

通常情况下，export输出的变量就是本来的名字，但是可以使用**as关键字**重命名。

```javascript
function f1() { ... }
function f2() { ... }
export {
  f1 as test1,
  f2 as test2,
  f2 as test3
};
```

上面代码使用as关键字，重命名了函数f1和f2的对外接口。重命名后，f2可以用不同的名字输出两次。

**正确的写法**

- `export var m = 1;`

- `var m = 1;  export {m};`

- `var n = 1;	export {n as m};`

- `export function f() {};`

- `function f() {}export {f};`



### import 关键字

使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。

```javascript
import { userName, userSex, userAge } from './module1.js';
console.log(userName);
console.log(userSex);
console.log(userAge);
```

如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。

`import { userName as xm } from './module1.js';`

import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。如果a是一个对象，改写a的属性是允许的。

`import {a} from './xxx.js'		a.foo = 'hello'; // 合法操作`

**import命令具有提升效果，会提升到整个模块的头部，首先执行。**

除了指定加载某些输出值，还可以使用整体加载，即用 * 指定一个对象，所有输出值都加载在这个对象上面。

```javascript
import * as obj from './module1.js';
console.log(obj.userName);
console.log(obj.userSex);
console.log(obj.userAge);
```

### export default 命令

为了给用户提供方便，用export default命令，为模块指定默认输出。

默认输出

```javascript
export default function test() { // 输出
  // ...
}
import test from './test.js'; // 输入
```

正常输出

```javascript
export function test() { // 输出
  // ...
};
import { test } from './test.js'; // 输入
```

使用export default时，对应的import语句不需要使用大括号；

不使用export default时，对应的import语句需要使用大括号。

**注意：**

一个模块只能有一个默认输出，因此export default命令只能使用一次。

因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。

```javascript
// 正确
export var a = 1;

// 正确
var a = 1;
export default a;

// 错误
export default var a = 1;

// 正确
export default 42;

// 报错
export 42;
```

## 浏览器加载规则

> 默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到script>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。

**浏览器两种异步加载的语法**

`<script src="path/to/myModule.js" defer></script>`

`<script src="path/to/myModule.js" async></script>`

上面代码中，script>标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。

**defer与async的区别**

defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；

async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染

**defer是“渲染完再执行”，async是“下载完就执行”。**

如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。

浏览器加载 ES6 模块，也使用script>标签，但是要加入type="module"属性。

浏览器对于带有type="module"的script>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了script>标签的defer属性。

`<script type="module" src="./foo.js" defer></script>`

## RequireJs

**什么是RequireJs**

> RequireJS是一个非常小巧的JavaScript模块载入框架，是AMD规范最好的实现者之一。
>
> AMD即Asynchronous Module Definition（异步模块定义）。
>
> AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。
>
> CMD即Common Moudle Definition（通用模块定义）。
>
> CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。

**AMD和CMD相同点：**

> - 都是异步加载模块；
> - 都实现了浏览器端模块化开发的目的；
> - 都倡导模块化开发理念，使前端模块化开发变得简单自然；
> - 解决前端开发过程中的两大问题：
>   1. 文件之间的依赖问题；
>   2. 浏览器加载多个JS文件时页面失去响应的时间过长。

**AMD和CMD不同点：**

> 1. 官方推荐的写法不同，AMD推崇依赖前置，CMD推崇依赖就近；
> 2. 模块的执行时机不同，AMD是提前执行，CMD是延迟执行；
> 3. api的设计不同，AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。



**"一个模块就是一个文件"**

**require 用来加载依赖模块，并执行加载完后的回调函数**

`require(['moduleA', 'moduleB'], function (a, b){ });`

第一个参数是依赖模块列表，第二个参数是一个callback函数

```javascript
//全局配置
require.config({
    baseUrl: 'js/lib',
    paths : {
        "jquery" : ["http://libs.baidu.com/jquery/2.0.3/jquery","jquery-2.1.4.min"],
        "mytask" : "myTask"   
    }
})
require(["jquery","mytask"],function($, mytask){
    $(function(){
       mytask("load finished");
    })
})
```

**require.config**是用来配置模块加载位置，简单点说就是**引入模块并起一个别名**

配置完成还要记得在html中设置**入口文件**

`<script src="js/require.js" data-main="js/main"></script>`

**define 用来定义一个模块**

```javascript
define({
　 // ...
    key: value
});

define(function( ){
　 // ...
    return {
        // ...
    }
});

define(['依赖的模块路径'], function(依赖模块名称){
　// ...
　return {
　　// ...
　};
});

define('模块名称', ['依赖的模块路径'], function(依赖模块名称){
　// ...
　return {
　　// ...
　};
});
```

